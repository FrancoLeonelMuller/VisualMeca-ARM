CCS PCH C Compiler, Version 5.015, 5967               15-nov-19 17:06

               Filename:   Z:\Mecatronica\Alumnos\Segundo\Haimovich\2DO AÑO\PROYECTO\MecaArm.X\build\default\production\main.lst

               ROM used:   11864 bytes (36%)
                           Largest free fragment is 20900
               RAM used:   382 (19%) at main() level
                           501 (24%) worst case
               Stack used: 6 locations (3 in main + 3 for interrupts)
               Stack size: 31

*
0000:  GOTO   2CD8
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.5
004A:  GOTO   0054
004E:  BTFSC  FF2.2
0050:  GOTO   0CD8
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   0122
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVF   04,W
0098:  MOVFF  06,FE0
009C:  MOVFF  05,FD8
00A0:  RETFIE 0
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                            MecaArm.c                            //// 
.................... ////                                                                 //// 
.................... ////                 MECATRONICA SISTEMA DUAL 2019                   //// 
.................... ////                                                                 //// 
.................... //// Programa controlador de los movimientos de los motores del      //// 
.................... //// brazo robótico Meca Arm.                                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
00A2:  MOVFF  FF2,0D
00A6:  BCF    FF2.7
00A8:  CLRF   FF7
00AA:  ADDLW  BC
00AC:  MOVWF  FF6
00AE:  MOVLW  00
00B0:  ADDWFC FF7,F
00B2:  TBLRD*+
00B4:  MOVF   FF5,W
00B6:  BTFSC  0D.7
00B8:  BSF    FF2.7
00BA:  RETURN 0
00BC:  DATA 30,30
00BE:  DATA 30,30
00C0:  DATA 30,00
*
00DA:  TBLRD*+
00DC:  MOVF   FF5,F
00DE:  BZ    00FA
00E0:  MOVFF  FF6,1E2
00E4:  MOVFF  FF7,1E3
00E8:  MOVF   FF5,W
00EA:  BTFSS  F9E.4
00EC:  BRA    00EA
00EE:  MOVWF  FAD
00F0:  MOVFF  1E2,FF6
00F4:  MOVFF  1E3,FF7
00F8:  BRA    00DA
00FA:  RETURN 0
00FC:  MOVF   FEF,F
00FE:  BZ    0120
0100:  MOVFF  FEA,1E3
0104:  MOVFF  FE9,1E2
0108:  MOVF   FEF,W
010A:  BTFSS  F9E.4
010C:  BRA    010A
010E:  MOVWF  FAD
0110:  MOVFF  1E3,FEA
0114:  MOVFF  1E2,FE9
0118:  INCF   FE9,F
011A:  BTFSC  FD8.2
011C:  INCF   FEA,F
011E:  BRA    00FC
0120:  RETURN 0
*
029C:  DATA 23,4F
029E:  DATA 4B,2D
02A0:  DATA 00,00
02A2:  MOVLB  1
02A4:  MOVF   xF0,W
02A6:  ANDLW  07
02A8:  MOVWF  00
02AA:  RRCF   xF0,W
02AC:  MOVWF  01
02AE:  RRCF   01,F
02B0:  RRCF   01,F
02B2:  MOVLW  1F
02B4:  ANDWF  01,F
02B6:  MOVF   01,W
02B8:  ADDWF  xF2,W
02BA:  MOVWF  FE9
02BC:  MOVLW  00
02BE:  ADDWFC xF3,W
02C0:  MOVWF  FEA
02C2:  CLRF   01
02C4:  INCF   01,F
02C6:  INCF   00,F
02C8:  BRA    02CC
02CA:  RLCF   01,F
02CC:  DECFSZ 00,F
02CE:  BRA    02CA
02D0:  MOVF   xF1,F
02D2:  BZ    02DA
02D4:  MOVF   01,W
02D6:  IORWF  FEF,F
02D8:  BRA    02E0
02DA:  COMF   01,F
02DC:  MOVF   01,W
02DE:  ANDWF  FEF,F
02E0:  MOVLB  0
02E2:  RETURN 0
02E4:  MOVLB  1
02E6:  MOVF   xF0,W
02E8:  ANDLW  07
02EA:  MOVWF  00
02EC:  RRCF   xF0,W
02EE:  MOVWF  01
02F0:  RRCF   01,F
02F2:  RRCF   01,F
02F4:  MOVLW  1F
02F6:  ANDWF  01,F
02F8:  MOVF   01,W
02FA:  ADDWF  xF1,W
02FC:  MOVWF  FE9
02FE:  MOVLW  00
0300:  ADDWFC xF2,W
0302:  MOVWF  FEA
0304:  MOVFF  FEF,01
0308:  INCF   00,F
030A:  BRA    030E
030C:  RRCF   01,F
030E:  DECFSZ 00,F
0310:  BRA    030C
0312:  MOVLB  0
0314:  RETURN 0
*
0E82:  DATA 24,53
0E84:  DATA 24,00
0E86:  DATA 24,46
0E88:  DATA 24,00
0E8A:  DATA 24,4F
0E8C:  DATA 4B,24
0E8E:  DATA 00,00
*
13C6:  MOVLB  1
13C8:  CLRF   xD4
13CA:  CLRF   xD5
13CC:  MOVLW  01
13CE:  MOVWF  xD6
13D0:  CLRF   FDA
13D2:  CLRF   FD9
13D4:  MOVWF  xD9
13D6:  MOVLW  CC
13D8:  MOVWF  xD8
13DA:  MOVLW  01
13DC:  MOVWF  FEA
13DE:  MOVLW  D0
13E0:  MOVWF  FE9
13E2:  MOVFF  1D9,FE2
13E6:  MOVFF  1D8,FE1
13EA:  MOVFF  1D6,1D7
13EE:  BCF    FD8.0
13F0:  MOVF   FE5,W
13F2:  MULWF  FEE
13F4:  MOVF   FF3,W
13F6:  ADDWFC xD4,F
13F8:  MOVF   FF4,W
13FA:  ADDWFC xD5,F
13FC:  DECFSZ xD7,F
13FE:  BRA    13EE
1400:  MOVFF  1D4,FDE
1404:  MOVFF  1D5,1D4
1408:  CLRF   xD5
140A:  BTFSC  FD8.0
140C:  INCF   xD5,F
140E:  INCF   xD8,F
1410:  BTFSC  FD8.2
1412:  INCF   xD9,F
1414:  INCF   xD6,F
1416:  MOVF   xD6,W
1418:  SUBLW  05
141A:  BNZ   13DA
141C:  MOVLB  0
141E:  GOTO   1540 (RETURN)
1422:  BTFSC  FD8.1
1424:  BRA    142E
1426:  MOVLW  01
1428:  MOVWF  FEA
142A:  MOVLW  DC
142C:  MOVWF  FE9
142E:  MOVLB  1
1430:  MOVF   xD7,W
1432:  XORWF  xDB,W
1434:  ANDLW  80
1436:  MOVWF  xE1
1438:  BTFSS  xD7.7
143A:  BRA    1452
143C:  COMF   xD4,F
143E:  COMF   xD5,F
1440:  COMF   xD6,F
1442:  COMF   xD7,F
1444:  INCF   xD4,F
1446:  BTFSC  FD8.2
1448:  INCF   xD5,F
144A:  BTFSC  FD8.2
144C:  INCF   xD6,F
144E:  BTFSC  FD8.2
1450:  INCF   xD7,F
1452:  BTFSS  xDB.7
1454:  BRA    146C
1456:  COMF   xD8,F
1458:  COMF   xD9,F
145A:  COMF   xDA,F
145C:  COMF   xDB,F
145E:  INCF   xD8,F
1460:  BTFSC  FD8.2
1462:  INCF   xD9,F
1464:  BTFSC  FD8.2
1466:  INCF   xDA,F
1468:  BTFSC  FD8.2
146A:  INCF   xDB,F
146C:  CLRF   00
146E:  CLRF   01
1470:  CLRF   02
1472:  CLRF   03
1474:  CLRF   xDC
1476:  CLRF   xDD
1478:  CLRF   xDE
147A:  CLRF   xDF
147C:  MOVF   xDB,W
147E:  IORWF  xDA,W
1480:  IORWF  xD9,W
1482:  IORWF  xD8,W
1484:  BZ    14DE
1486:  MOVLW  20
1488:  MOVWF  xE0
148A:  BCF    FD8.0
148C:  RLCF   xD4,F
148E:  RLCF   xD5,F
1490:  RLCF   xD6,F
1492:  RLCF   xD7,F
1494:  RLCF   xDC,F
1496:  RLCF   xDD,F
1498:  RLCF   xDE,F
149A:  RLCF   xDF,F
149C:  MOVF   xDB,W
149E:  SUBWF  xDF,W
14A0:  BNZ   14B2
14A2:  MOVF   xDA,W
14A4:  SUBWF  xDE,W
14A6:  BNZ   14B2
14A8:  MOVF   xD9,W
14AA:  SUBWF  xDD,W
14AC:  BNZ   14B2
14AE:  MOVF   xD8,W
14B0:  SUBWF  xDC,W
14B2:  BNC   14D2
14B4:  MOVF   xD8,W
14B6:  SUBWF  xDC,F
14B8:  MOVF   xD9,W
14BA:  BTFSS  FD8.0
14BC:  INCFSZ xD9,W
14BE:  SUBWF  xDD,F
14C0:  MOVF   xDA,W
14C2:  BTFSS  FD8.0
14C4:  INCFSZ xDA,W
14C6:  SUBWF  xDE,F
14C8:  MOVF   xDB,W
14CA:  BTFSS  FD8.0
14CC:  INCFSZ xDB,W
14CE:  SUBWF  xDF,F
14D0:  BSF    FD8.0
14D2:  RLCF   00,F
14D4:  RLCF   01,F
14D6:  RLCF   02,F
14D8:  RLCF   03,F
14DA:  DECFSZ xE0,F
14DC:  BRA    148A
14DE:  BTFSS  xE1.7
14E0:  BRA    14F8
14E2:  COMF   00,F
14E4:  COMF   01,F
14E6:  COMF   02,F
14E8:  COMF   03,F
14EA:  INCF   00,F
14EC:  BTFSC  FD8.2
14EE:  INCF   01,F
14F0:  BTFSC  FD8.2
14F2:  INCF   02,F
14F4:  BTFSC  FD8.2
14F6:  INCF   03,F
14F8:  MOVFF  1DC,FEF
14FC:  MOVFF  1DD,FEC
1500:  MOVFF  1DE,FEC
1504:  MOVFF  1DF,FEC
1508:  MOVLB  0
150A:  RETURN 0
*
1F60:  MOVFF  FF2,0D
1F64:  BCF    FF2.7
1F66:  ADDWF  FE8,W
1F68:  CLRF   FF7
1F6A:  RLCF   FF7,F
1F6C:  ADDLW  85
1F6E:  MOVWF  FF6
1F70:  MOVLW  1F
1F72:  ADDWFC FF7,F
1F74:  TBLRD*-
1F76:  MOVF   FF5,W
1F78:  MOVWF  FFA
1F7A:  TBLRD*
1F7C:  MOVF   FF5,W
1F7E:  BTFSC  0D.7
1F80:  BSF    FF2.7
1F82:  MOVWF  FF9
1F84:  DATA E0,1E
1F86:  DATA E8,1E
1F88:  DATA F0,1E
1F8A:  DATA F8,1E
1F8C:  DATA 00,1F
1F8E:  DATA 08,1F
1F90:  MOVLB  1
1F92:  MOVF   x92,W
1F94:  BTFSC  FD8.2
1F96:  BRA    207A
1F98:  MOVWF  00
1F9A:  MOVF   x96,W
1F9C:  BTFSC  FD8.2
1F9E:  BRA    207A
1FA0:  ADDWF  00,F
1FA2:  BNC   1FAC
1FA4:  MOVLW  81
1FA6:  ADDWF  00,F
1FA8:  BC    207A
1FAA:  BRA    1FB4
1FAC:  MOVLW  7F
1FAE:  SUBWF  00,F
1FB0:  BNC   207A
1FB2:  BZ    207A
1FB4:  MOVFF  193,19A
1FB8:  MOVF   x97,W
1FBA:  XORWF  x9A,F
1FBC:  BSF    x93.7
1FBE:  BSF    x97.7
1FC0:  MOVF   x95,W
1FC2:  MULWF  x99
1FC4:  MOVFF  FF4,19C
1FC8:  MOVF   x94,W
1FCA:  MULWF  x98
1FCC:  MOVFF  FF4,03
1FD0:  MOVFF  FF3,19B
1FD4:  MULWF  x99
1FD6:  MOVF   FF3,W
1FD8:  ADDWF  x9C,F
1FDA:  MOVF   FF4,W
1FDC:  ADDWFC x9B,F
1FDE:  MOVLW  00
1FE0:  ADDWFC 03,F
1FE2:  MOVF   x95,W
1FE4:  MULWF  x98
1FE6:  MOVF   FF3,W
1FE8:  ADDWF  x9C,F
1FEA:  MOVF   FF4,W
1FEC:  ADDWFC x9B,F
1FEE:  MOVLW  00
1FF0:  CLRF   02
1FF2:  ADDWFC 03,F
1FF4:  ADDWFC 02,F
1FF6:  MOVF   x93,W
1FF8:  MULWF  x99
1FFA:  MOVF   FF3,W
1FFC:  ADDWF  x9B,F
1FFE:  MOVF   FF4,W
2000:  ADDWFC 03,F
2002:  MOVLW  00
2004:  ADDWFC 02,F
2006:  MOVF   x93,W
2008:  MULWF  x98
200A:  MOVF   FF3,W
200C:  ADDWF  03,F
200E:  MOVF   FF4,W
2010:  ADDWFC 02,F
2012:  MOVLW  00
2014:  CLRF   01
2016:  ADDWFC 01,F
2018:  MOVF   x95,W
201A:  MULWF  x97
201C:  MOVF   FF3,W
201E:  ADDWF  x9B,F
2020:  MOVF   FF4,W
2022:  ADDWFC 03,F
2024:  MOVLW  00
2026:  ADDWFC 02,F
2028:  ADDWFC 01,F
202A:  MOVF   x94,W
202C:  MULWF  x97
202E:  MOVF   FF3,W
2030:  ADDWF  03,F
2032:  MOVF   FF4,W
2034:  ADDWFC 02,F
2036:  MOVLW  00
2038:  ADDWFC 01,F
203A:  MOVF   x93,W
203C:  MULWF  x97
203E:  MOVF   FF3,W
2040:  ADDWF  02,F
2042:  MOVF   FF4,W
2044:  ADDWFC 01,F
2046:  INCF   00,F
2048:  BTFSC  01.7
204A:  BRA    2056
204C:  RLCF   x9B,F
204E:  RLCF   03,F
2050:  RLCF   02,F
2052:  RLCF   01,F
2054:  DECF   00,F
2056:  MOVLW  00
2058:  BTFSS  x9B.7
205A:  BRA    2070
205C:  INCF   03,F
205E:  ADDWFC 02,F
2060:  ADDWFC 01,F
2062:  MOVF   01,W
2064:  BNZ   2070
2066:  MOVF   02,W
2068:  BNZ   2070
206A:  MOVF   03,W
206C:  BNZ   2070
206E:  INCF   00,F
2070:  BTFSC  x9A.7
2072:  BSF    01.7
2074:  BTFSS  x9A.7
2076:  BCF    01.7
2078:  BRA    2082
207A:  CLRF   00
207C:  CLRF   01
207E:  CLRF   02
2080:  CLRF   03
2082:  MOVLB  0
2084:  RETURN 0
2086:  MOVLW  8E
2088:  MOVWF  00
208A:  MOVFF  197,01
208E:  MOVFF  196,02
2092:  CLRF   03
2094:  MOVF   01,F
2096:  BNZ   20AA
2098:  MOVFF  02,01
209C:  CLRF   02
209E:  MOVLW  08
20A0:  SUBWF  00,F
20A2:  MOVF   01,F
20A4:  BNZ   20AA
20A6:  CLRF   00
20A8:  BRA    20BA
20AA:  BCF    FD8.0
20AC:  BTFSC  01.7
20AE:  BRA    20B8
20B0:  RLCF   02,F
20B2:  RLCF   01,F
20B4:  DECF   00,F
20B6:  BRA    20AA
20B8:  BCF    01.7
20BA:  RETURN 0
20BC:  MOVLB  1
20BE:  MOVF   x96,W
20C0:  BTFSC  FD8.2
20C2:  BRA    220E
20C4:  MOVWF  xA2
20C6:  MOVF   x9A,W
20C8:  BTFSC  FD8.2
20CA:  BRA    220E
20CC:  SUBWF  xA2,F
20CE:  BNC   20DA
20D0:  MOVLW  7F
20D2:  ADDWF  xA2,F
20D4:  BTFSC  FD8.0
20D6:  BRA    220E
20D8:  BRA    20E6
20DA:  MOVLW  81
20DC:  SUBWF  xA2,F
20DE:  BTFSS  FD8.0
20E0:  BRA    220E
20E2:  BTFSC  FD8.2
20E4:  BRA    220E
20E6:  MOVFF  1A2,00
20EA:  CLRF   01
20EC:  CLRF   02
20EE:  CLRF   03
20F0:  CLRF   xA1
20F2:  MOVFF  197,1A0
20F6:  BSF    xA0.7
20F8:  MOVFF  198,19F
20FC:  MOVFF  199,19E
2100:  MOVLW  19
2102:  MOVWF  xA2
2104:  MOVF   x9D,W
2106:  SUBWF  x9E,F
2108:  BC    2124
210A:  MOVLW  01
210C:  SUBWF  x9F,F
210E:  BC    2124
2110:  SUBWF  xA0,F
2112:  BC    2124
2114:  SUBWF  xA1,F
2116:  BC    2124
2118:  INCF   xA1,F
211A:  INCF   xA0,F
211C:  INCF   x9F,F
211E:  MOVF   x9D,W
2120:  ADDWF  x9E,F
2122:  BRA    2174
2124:  MOVF   x9C,W
2126:  SUBWF  x9F,F
2128:  BC    214E
212A:  MOVLW  01
212C:  SUBWF  xA0,F
212E:  BC    214E
2130:  SUBWF  xA1,F
2132:  BC    214E
2134:  INCF   xA1,F
2136:  INCF   xA0,F
2138:  MOVF   x9C,W
213A:  ADDWF  x9F,F
213C:  MOVF   x9D,W
213E:  ADDWF  x9E,F
2140:  BNC   2174
2142:  INCF   x9F,F
2144:  BNZ   2174
2146:  INCF   xA0,F
2148:  BNZ   2174
214A:  INCF   xA1,F
214C:  BRA    2174
214E:  MOVF   x9B,W
2150:  IORLW  80
2152:  SUBWF  xA0,F
2154:  BC    2172
2156:  MOVLW  01
2158:  SUBWF  xA1,F
215A:  BC    2172
215C:  INCF   xA1,F
215E:  MOVF   x9B,W
2160:  IORLW  80
2162:  ADDWF  xA0,F
2164:  MOVF   x9C,W
2166:  ADDWF  x9F,F
2168:  BNC   213C
216A:  INCF   xA0,F
216C:  BNZ   213C
216E:  INCF   xA1,F
2170:  BRA    213C
2172:  BSF    03.0
2174:  DECFSZ xA2,F
2176:  BRA    217A
2178:  BRA    2190
217A:  BCF    FD8.0
217C:  RLCF   x9E,F
217E:  RLCF   x9F,F
2180:  RLCF   xA0,F
2182:  RLCF   xA1,F
2184:  BCF    FD8.0
2186:  RLCF   03,F
2188:  RLCF   02,F
218A:  RLCF   01,F
218C:  RLCF   xA3,F
218E:  BRA    2104
2190:  BTFSS  xA3.0
2192:  BRA    21A0
2194:  BCF    FD8.0
2196:  RRCF   01,F
2198:  RRCF   02,F
219A:  RRCF   03,F
219C:  RRCF   xA3,F
219E:  BRA    21A4
21A0:  DECF   00,F
21A2:  BZ    220E
21A4:  BTFSC  xA3.7
21A6:  BRA    21E4
21A8:  BCF    FD8.0
21AA:  RLCF   x9E,F
21AC:  RLCF   x9F,F
21AE:  RLCF   xA0,F
21B0:  RLCF   xA1,F
21B2:  MOVF   x9D,W
21B4:  SUBWF  x9E,F
21B6:  BC    21C6
21B8:  MOVLW  01
21BA:  SUBWF  x9F,F
21BC:  BC    21C6
21BE:  SUBWF  xA0,F
21C0:  BC    21C6
21C2:  SUBWF  xA1,F
21C4:  BNC   21FA
21C6:  MOVF   x9C,W
21C8:  SUBWF  x9F,F
21CA:  BC    21D6
21CC:  MOVLW  01
21CE:  SUBWF  xA0,F
21D0:  BC    21D6
21D2:  SUBWF  xA1,F
21D4:  BNC   21FA
21D6:  MOVF   x9B,W
21D8:  IORLW  80
21DA:  SUBWF  xA0,F
21DC:  BC    21E4
21DE:  MOVLW  01
21E0:  SUBWF  xA1,F
21E2:  BNC   21FA
21E4:  INCF   03,F
21E6:  BNZ   21FA
21E8:  INCF   02,F
21EA:  BNZ   21FA
21EC:  INCF   01,F
21EE:  BNZ   21FA
21F0:  INCF   00,F
21F2:  BZ    220E
21F4:  RRCF   01,F
21F6:  RRCF   02,F
21F8:  RRCF   03,F
21FA:  MOVFF  197,1A2
21FE:  MOVF   x9B,W
2200:  XORWF  xA2,F
2202:  BTFSS  xA2.7
2204:  BRA    220A
2206:  BSF    01.7
2208:  BRA    2216
220A:  BCF    01.7
220C:  BRA    2216
220E:  CLRF   00
2210:  CLRF   01
2212:  CLRF   02
2214:  CLRF   03
2216:  MOVLB  0
2218:  GOTO   2598 (RETURN)
221C:  MOVLW  80
221E:  BTFSS  FD8.1
2220:  BRA    2226
2222:  MOVLB  1
2224:  XORWF  x9B,F
2226:  MOVLB  1
2228:  CLRF   xA0
222A:  CLRF   xA1
222C:  MOVFF  197,19F
2230:  MOVF   x9B,W
2232:  XORWF  x9F,F
2234:  MOVF   x96,W
2236:  BTFSC  FD8.2
2238:  BRA    23F8
223A:  MOVWF  x9E
223C:  MOVWF  00
223E:  MOVF   x9A,W
2240:  BTFSC  FD8.2
2242:  BRA    240A
2244:  SUBWF  x9E,F
2246:  BTFSC  FD8.2
2248:  BRA    2350
224A:  BNC   22C8
224C:  MOVFF  19B,1A4
2250:  BSF    xA4.7
2252:  MOVFF  19C,1A3
2256:  MOVFF  19D,1A2
225A:  CLRF   xA1
225C:  BCF    FD8.0
225E:  RRCF   xA4,F
2260:  RRCF   xA3,F
2262:  RRCF   xA2,F
2264:  RRCF   xA1,F
2266:  DECFSZ x9E,F
2268:  BRA    225A
226A:  BTFSS  x9F.7
226C:  BRA    2274
226E:  BSF    xA0.0
2270:  BRA    2432
2272:  BCF    xA0.0
2274:  BCF    x9E.0
2276:  BSF    xA0.4
2278:  MOVLW  01
227A:  MOVWF  FEA
227C:  MOVLW  99
227E:  MOVWF  FE9
2280:  BRA    2458
2282:  BCF    xA0.4
2284:  BTFSC  x9F.7
2286:  BRA    229C
2288:  BTFSS  x9E.0
228A:  BRA    22B2
228C:  RRCF   xA4,F
228E:  RRCF   xA3,F
2290:  RRCF   xA2,F
2292:  RRCF   xA1,F
2294:  INCF   00,F
2296:  BTFSC  FD8.2
2298:  BRA    2428
229A:  BRA    22B2
229C:  BTFSC  xA4.7
229E:  BRA    22B8
22A0:  BCF    FD8.0
22A2:  RLCF   xA1,F
22A4:  RLCF   xA2,F
22A6:  RLCF   xA3,F
22A8:  RLCF   xA4,F
22AA:  DECF   00,F
22AC:  BTFSC  FD8.2
22AE:  BRA    2428
22B0:  BRA    229C
22B2:  BSF    xA0.6
22B4:  BRA    2390
22B6:  BCF    xA0.6
22B8:  MOVFF  197,19F
22BC:  BTFSS  x97.7
22BE:  BRA    22C4
22C0:  BSF    xA4.7
22C2:  BRA    241A
22C4:  BCF    xA4.7
22C6:  BRA    241A
22C8:  MOVFF  19A,19E
22CC:  MOVFF  19A,00
22D0:  MOVF   x96,W
22D2:  SUBWF  x9E,F
22D4:  MOVFF  197,1A4
22D8:  BSF    xA4.7
22DA:  MOVFF  198,1A3
22DE:  MOVFF  199,1A2
22E2:  CLRF   xA1
22E4:  BCF    FD8.0
22E6:  RRCF   xA4,F
22E8:  RRCF   xA3,F
22EA:  RRCF   xA2,F
22EC:  RRCF   xA1,F
22EE:  DECFSZ x9E,F
22F0:  BRA    22E2
22F2:  BTFSS  x9F.7
22F4:  BRA    22FC
22F6:  BSF    xA0.1
22F8:  BRA    2432
22FA:  BCF    xA0.1
22FC:  BCF    x9E.0
22FE:  BSF    xA0.5
2300:  MOVLW  01
2302:  MOVWF  FEA
2304:  MOVLW  9D
2306:  MOVWF  FE9
2308:  BRA    2458
230A:  BCF    xA0.5
230C:  BTFSC  x9F.7
230E:  BRA    2324
2310:  BTFSS  x9E.0
2312:  BRA    233A
2314:  RRCF   xA4,F
2316:  RRCF   xA3,F
2318:  RRCF   xA2,F
231A:  RRCF   xA1,F
231C:  INCF   00,F
231E:  BTFSC  FD8.2
2320:  BRA    2428
2322:  BRA    233A
2324:  BTFSC  xA4.7
2326:  BRA    2340
2328:  BCF    FD8.0
232A:  RLCF   xA1,F
232C:  RLCF   xA2,F
232E:  RLCF   xA3,F
2330:  RLCF   xA4,F
2332:  DECF   00,F
2334:  BTFSC  FD8.2
2336:  BRA    2428
2338:  BRA    2324
233A:  BSF    xA0.7
233C:  BRA    2390
233E:  BCF    xA0.7
2340:  MOVFF  19B,19F
2344:  BTFSS  x9B.7
2346:  BRA    234C
2348:  BSF    xA4.7
234A:  BRA    241A
234C:  BCF    xA4.7
234E:  BRA    241A
2350:  MOVFF  19B,1A4
2354:  BSF    xA4.7
2356:  MOVFF  19C,1A3
235A:  MOVFF  19D,1A2
235E:  BTFSS  x9F.7
2360:  BRA    236A
2362:  BCF    xA4.7
2364:  BSF    xA0.2
2366:  BRA    2432
2368:  BCF    xA0.2
236A:  CLRF   xA1
236C:  BCF    x9E.0
236E:  MOVLW  01
2370:  MOVWF  FEA
2372:  MOVLW  99
2374:  MOVWF  FE9
2376:  BRA    2458
2378:  BTFSC  x9F.7
237A:  BRA    23B4
237C:  MOVFF  197,19F
2380:  BTFSS  x9E.0
2382:  BRA    2390
2384:  RRCF   xA4,F
2386:  RRCF   xA3,F
2388:  RRCF   xA2,F
238A:  RRCF   xA1,F
238C:  INCF   00,F
238E:  BZ    2428
2390:  BTFSS  xA1.7
2392:  BRA    23AA
2394:  INCF   xA2,F
2396:  BNZ   23AA
2398:  INCF   xA3,F
239A:  BNZ   23AA
239C:  INCF   xA4,F
239E:  BNZ   23AA
23A0:  RRCF   xA4,F
23A2:  RRCF   xA3,F
23A4:  RRCF   xA2,F
23A6:  INCF   00,F
23A8:  BZ    2428
23AA:  BTFSC  xA0.6
23AC:  BRA    22B6
23AE:  BTFSC  xA0.7
23B0:  BRA    233E
23B2:  BRA    23EC
23B4:  MOVLW  80
23B6:  XORWF  xA4,F
23B8:  BTFSS  xA4.7
23BA:  BRA    23C4
23BC:  BRA    2432
23BE:  MOVFF  19B,19F
23C2:  BRA    23D8
23C4:  MOVFF  197,19F
23C8:  MOVF   xA4,F
23CA:  BNZ   23D8
23CC:  MOVF   xA3,F
23CE:  BNZ   23D8
23D0:  MOVF   xA2,F
23D2:  BNZ   23D8
23D4:  CLRF   00
23D6:  BRA    241A
23D8:  BTFSC  xA4.7
23DA:  BRA    23EC
23DC:  BCF    FD8.0
23DE:  RLCF   xA1,F
23E0:  RLCF   xA2,F
23E2:  RLCF   xA3,F
23E4:  RLCF   xA4,F
23E6:  DECFSZ 00,F
23E8:  BRA    23D8
23EA:  BRA    2428
23EC:  BTFSS  x9F.7
23EE:  BRA    23F4
23F0:  BSF    xA4.7
23F2:  BRA    241A
23F4:  BCF    xA4.7
23F6:  BRA    241A
23F8:  MOVFF  19A,00
23FC:  MOVFF  19B,1A4
2400:  MOVFF  19C,1A3
2404:  MOVFF  19D,1A2
2408:  BRA    241A
240A:  MOVFF  196,00
240E:  MOVFF  197,1A4
2412:  MOVFF  198,1A3
2416:  MOVFF  199,1A2
241A:  MOVFF  1A4,01
241E:  MOVFF  1A3,02
2422:  MOVFF  1A2,03
2426:  BRA    2490
2428:  CLRF   00
242A:  CLRF   01
242C:  CLRF   02
242E:  CLRF   03
2430:  BRA    2490
2432:  CLRF   xA1
2434:  COMF   xA2,F
2436:  COMF   xA3,F
2438:  COMF   xA4,F
243A:  COMF   xA1,F
243C:  INCF   xA1,F
243E:  BNZ   244A
2440:  INCF   xA2,F
2442:  BNZ   244A
2444:  INCF   xA3,F
2446:  BNZ   244A
2448:  INCF   xA4,F
244A:  BTFSC  xA0.0
244C:  BRA    2272
244E:  BTFSC  xA0.1
2450:  BRA    22FA
2452:  BTFSC  xA0.2
2454:  BRA    2368
2456:  BRA    23BE
2458:  MOVF   FEF,W
245A:  ADDWF  xA2,F
245C:  BNC   2468
245E:  INCF   xA3,F
2460:  BNZ   2468
2462:  INCF   xA4,F
2464:  BTFSC  FD8.2
2466:  BSF    x9E.0
2468:  MOVF   FED,F
246A:  MOVF   FEF,W
246C:  ADDWF  xA3,F
246E:  BNC   2476
2470:  INCF   xA4,F
2472:  BTFSC  FD8.2
2474:  BSF    x9E.0
2476:  MOVF   FED,F
2478:  MOVF   FEF,W
247A:  BTFSC  FEF.7
247C:  BRA    2480
247E:  XORLW  80
2480:  ADDWF  xA4,F
2482:  BTFSC  FD8.0
2484:  BSF    x9E.0
2486:  BTFSC  xA0.4
2488:  BRA    2282
248A:  BTFSC  xA0.5
248C:  BRA    230A
248E:  BRA    2378
2490:  MOVLB  0
2492:  RETURN 0
*
26E4:  MOVLB  1
26E6:  MOVF   x83,W
26E8:  SUBLW  B6
26EA:  MOVWF  x83
26EC:  CLRF   03
26EE:  MOVFF  184,187
26F2:  BSF    x84.7
26F4:  BCF    FD8.0
26F6:  RRCF   x84,F
26F8:  RRCF   x85,F
26FA:  RRCF   x86,F
26FC:  RRCF   03,F
26FE:  RRCF   02,F
2700:  RRCF   01,F
2702:  RRCF   00,F
2704:  DECFSZ x83,F
2706:  BRA    26F4
2708:  BTFSS  x87.7
270A:  BRA    2722
270C:  COMF   00,F
270E:  COMF   01,F
2710:  COMF   02,F
2712:  COMF   03,F
2714:  INCF   00,F
2716:  BTFSC  FD8.2
2718:  INCF   01,F
271A:  BTFSC  FD8.2
271C:  INCF   02,F
271E:  BTFSC  FD8.2
2720:  INCF   03,F
2722:  MOVLB  0
2724:  GOTO   28D0 (RETURN)
....................  
.................... #list 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
150C:  MOVLB  1
150E:  CLRF   xC7
1510:  CLRF   xC6
1512:  CLRF   xC5
1514:  MOVLW  01
1516:  MOVWF  xC4
1518:  CLRF   xC9
151A:  CLRF   xCA
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
151C:  BTFSS  xC0.7
151E:  BRA    1552
....................          sign=1;        // Check for negative number 
1520:  MOVLW  01
1522:  MOVWF  xC9
....................          num*=-1; 
1524:  MOVFF  1C0,1CF
1528:  MOVFF  1BF,1CE
152C:  MOVFF  1BE,1CD
1530:  MOVFF  1BD,1CC
1534:  SETF   xD3
1536:  SETF   xD2
1538:  SETF   xD1
153A:  SETF   xD0
153C:  MOVLB  0
153E:  BRA    13C6
1540:  MOVFF  03,1C0
1544:  MOVFF  02,1BF
1548:  MOVFF  01,1BE
154C:  MOVFF  00,1BD
1550:  MOVLB  1
....................      } 
....................  
....................      while(temp>0) { 
1552:  MOVF   xC4,F
1554:  BNZ   1562
1556:  MOVF   xC5,F
1558:  BNZ   1562
155A:  MOVF   xC6,F
155C:  BNZ   1562
155E:  MOVF   xC7,F
1560:  BZ    163C
....................          temp=(num/base); 
1562:  BCF    FD8.1
1564:  MOVFF  1C0,1D7
1568:  MOVFF  1BF,1D6
156C:  MOVFF  1BE,1D5
1570:  MOVFF  1BD,1D4
1574:  CLRF   xDB
1576:  CLRF   xDA
1578:  CLRF   xD9
157A:  MOVFF  1C1,1D8
157E:  MOVLB  0
1580:  RCALL  1422
1582:  MOVFF  03,1C7
1586:  MOVFF  02,1C6
158A:  MOVFF  01,1C5
158E:  MOVFF  00,1C4
....................          s[cnt]=(num%base)+'0';    // Conversion 
1592:  CLRF   03
1594:  MOVLB  1
1596:  MOVF   xCA,W
1598:  ADDWF  xC2,W
159A:  MOVWF  01
159C:  MOVF   xC3,W
159E:  ADDWFC 03,F
15A0:  MOVFF  01,1CC
15A4:  MOVFF  03,1CD
15A8:  MOVFF  FEA,1CF
15AC:  MOVFF  FE9,1CE
15B0:  BSF    FD8.1
15B2:  MOVLW  01
15B4:  MOVWF  FEA
15B6:  MOVLW  D0
15B8:  MOVWF  FE9
15BA:  MOVFF  1C0,1D7
15BE:  MOVFF  1BF,1D6
15C2:  MOVFF  1BE,1D5
15C6:  MOVFF  1BD,1D4
15CA:  CLRF   xDB
15CC:  CLRF   xDA
15CE:  CLRF   xD9
15D0:  MOVFF  1C1,1D8
15D4:  MOVLB  0
15D6:  RCALL  1422
15D8:  MOVFF  1CF,FEA
15DC:  MOVFF  1CE,FE9
15E0:  MOVLW  30
15E2:  MOVLB  1
15E4:  ADDWF  xD0,W
15E6:  MOVWF  00
15E8:  MOVLW  00
15EA:  ADDWFC xD1,W
15EC:  MOVLW  00
15EE:  ADDWFC xD2,W
15F0:  MOVLW  00
15F2:  ADDWFC xD3,W
15F4:  MOVFF  1CD,FEA
15F8:  MOVFF  1CC,FE9
15FC:  MOVFF  00,FEF
....................  
....................          if(s[cnt]>0x39) 
1600:  CLRF   03
1602:  MOVF   xCA,W
1604:  ADDWF  xC2,W
1606:  MOVWF  FE9
1608:  MOVF   xC3,W
160A:  ADDWFC 03,W
160C:  MOVWF  FEA
160E:  MOVF   FEF,W
1610:  SUBLW  39
1612:  BC    1628
....................             s[cnt]+=0x7; 
1614:  CLRF   03
1616:  MOVF   xCA,W
1618:  ADDWF  xC2,W
161A:  MOVWF  FE9
161C:  MOVF   xC3,W
161E:  ADDWFC 03,W
1620:  MOVWF  FEA
1622:  MOVLW  07
1624:  ADDWF  FEF,W
1626:  MOVWF  FEF
....................  
....................          cnt++; 
1628:  INCF   xCA,F
....................          num=temp; 
162A:  MOVFF  1C7,1C0
162E:  MOVFF  1C6,1BF
1632:  MOVFF  1C5,1BE
1636:  MOVFF  1C4,1BD
163A:  BRA    1552
....................      } 
....................  
....................      if(sign==1) { 
163C:  DECFSZ xC9,W
163E:  BRA    1654
....................          s[cnt]=0x2D;      // Negative sign 
1640:  CLRF   03
1642:  MOVF   xCA,W
1644:  ADDWF  xC2,W
1646:  MOVWF  FE9
1648:  MOVF   xC3,W
164A:  ADDWFC 03,W
164C:  MOVWF  FEA
164E:  MOVLW  2D
1650:  MOVWF  FEF
....................          cnt++; 
1652:  INCF   xCA,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
1654:  CLRF   xC8
1656:  BCF    FD8.0
1658:  RRCF   xCA,W
165A:  SUBWF  xC8,W
165C:  BC    16BC
....................  
....................          c=s[i]; 
165E:  CLRF   03
1660:  MOVF   xC8,W
1662:  ADDWF  xC2,W
1664:  MOVWF  FE9
1666:  MOVF   xC3,W
1668:  ADDWFC 03,W
166A:  MOVWF  FEA
166C:  MOVFF  FEF,1CB
....................          s[i]=s[cnt-i-1];        // Reverse the number 
1670:  CLRF   03
1672:  MOVF   xC8,W
1674:  ADDWF  xC2,W
1676:  MOVWF  01
1678:  MOVF   xC3,W
167A:  ADDWFC 03,F
167C:  MOVFF  03,1CD
1680:  MOVF   xC8,W
1682:  SUBWF  xCA,W
1684:  ADDLW  FF
1686:  CLRF   03
1688:  ADDWF  xC2,W
168A:  MOVWF  FE9
168C:  MOVF   xC3,W
168E:  ADDWFC 03,W
1690:  MOVWF  FEA
1692:  MOVFF  FEF,1CE
1696:  MOVFF  1CD,FEA
169A:  MOVFF  01,FE9
169E:  MOVFF  1CE,FEF
....................          s[cnt-i-1]=c; 
16A2:  MOVF   xC8,W
16A4:  SUBWF  xCA,W
16A6:  ADDLW  FF
16A8:  CLRF   03
16AA:  ADDWF  xC2,W
16AC:  MOVWF  FE9
16AE:  MOVF   xC3,W
16B0:  ADDWFC 03,W
16B2:  MOVWF  FEA
16B4:  MOVFF  1CB,FEF
16B8:  INCF   xC8,F
16BA:  BRA    1656
....................      } 
....................      s[cnt]='\0';     // End the string 
16BC:  CLRF   03
16BE:  MOVF   xCA,W
16C0:  ADDWF  xC2,W
16C2:  MOVWF  FE9
16C4:  MOVF   xC3,W
16C6:  ADDWFC 03,W
16C8:  MOVWF  FEA
16CA:  CLRF   FEF
....................      return s; 
16CC:  MOVFF  1C2,01
16D0:  MOVFF  1C3,02
16D4:  MOVLB  0
16D6:  GOTO   1892 (RETURN)
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
*
2494:  MOVLB  1
2496:  CLRF   x8A
2498:  CLRF   x89
249A:  CLRF   x88
249C:  MOVLW  7F
249E:  MOVWF  x87
24A0:  CLRF   x8E
24A2:  CLRF   x8D
24A4:  CLRF   x8C
24A6:  CLRF   x8B
24A8:  BSF    x8F.0
24AA:  BCF    x8F.1
24AC:  BCF    x8F.2
24AE:  CLRF   x91
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
24B0:  MOVF   x83,W
24B2:  IORWF  x84,W
24B4:  BNZ   24C0
....................       return 0; 
24B6:  CLRF   00
24B8:  CLRF   01
24BA:  CLRF   02
24BC:  CLRF   03
24BE:  BRA    26DE
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
24C0:  MOVF   x91,W
24C2:  INCF   x91,F
24C4:  CLRF   03
24C6:  ADDWF  x83,W
24C8:  MOVWF  FE9
24CA:  MOVF   x84,W
24CC:  ADDWFC 03,W
24CE:  MOVWF  FEA
24D0:  MOVFF  FEF,190
24D4:  MOVF   x90,F
24D6:  BTFSC  FD8.2
24D8:  BRA    2664
....................    { 
....................       if (skip && !isspace(c)) 
24DA:  BTFSS  x8F.0
24DC:  BRA    24FC
24DE:  MOVF   x90,W
24E0:  SUBLW  20
24E2:  BZ    24FC
....................       { 
....................          skip = 0; 
24E4:  BCF    x8F.0
....................          if (c == '+') 
24E6:  MOVF   x90,W
24E8:  SUBLW  2B
24EA:  BNZ   24F2
....................          { 
....................             sign = 0; 
24EC:  BCF    x8F.1
....................             continue; 
24EE:  BRA    264A
....................          }             
24F0:  BRA    24FC
....................          else if (c == '-') 
24F2:  MOVF   x90,W
24F4:  SUBLW  2D
24F6:  BNZ   24FC
....................          { 
....................             sign = 1; 
24F8:  BSF    x8F.1
....................             continue; 
24FA:  BRA    264A
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
24FC:  BTFSC  x8F.0
24FE:  BRA    250E
2500:  MOVF   x90,W
2502:  SUBLW  2E
2504:  BNZ   250E
2506:  BTFSC  x8F.2
2508:  BRA    250E
....................          point = 1; 
250A:  BSF    x8F.2
250C:  BRA    264A
....................       else if (!skip && isdigit(c)) 
250E:  BTFSC  x8F.0
2510:  BRA    2644
2512:  MOVF   x90,W
2514:  SUBLW  2F
2516:  BTFSC  FD8.0
2518:  BRA    2644
251A:  MOVF   x90,W
251C:  SUBLW  39
251E:  BTFSS  FD8.0
2520:  BRA    2644
....................       { 
....................          c -= '0'; 
2522:  MOVLW  30
2524:  SUBWF  x90,F
....................          if (point) 
2526:  BTFSS  x8F.2
2528:  BRA    25D0
....................          { 
....................             pow10 = pow10 * 10.0; 
252A:  MOVFF  18A,195
252E:  MOVFF  189,194
2532:  MOVFF  188,193
2536:  MOVFF  187,192
253A:  CLRF   x99
253C:  CLRF   x98
253E:  MOVLW  20
2540:  MOVWF  x97
2542:  MOVLW  82
2544:  MOVWF  x96
2546:  MOVLB  0
2548:  RCALL  1F90
254A:  MOVFF  03,18A
254E:  MOVFF  02,189
2552:  MOVFF  01,188
2556:  MOVFF  00,187
....................             result += (float)c / pow10;    
255A:  MOVLB  1
255C:  CLRF   x97
255E:  MOVFF  190,196
2562:  MOVLB  0
2564:  RCALL  2086
2566:  MOVFF  03,195
256A:  MOVFF  02,194
256E:  MOVFF  01,193
2572:  MOVFF  00,192
2576:  MOVFF  03,199
257A:  MOVFF  02,198
257E:  MOVFF  01,197
2582:  MOVFF  00,196
2586:  MOVFF  18A,19D
258A:  MOVFF  189,19C
258E:  MOVFF  188,19B
2592:  MOVFF  187,19A
2596:  BRA    20BC
2598:  BCF    FD8.1
259A:  MOVFF  18E,199
259E:  MOVFF  18D,198
25A2:  MOVFF  18C,197
25A6:  MOVFF  18B,196
25AA:  MOVFF  03,19D
25AE:  MOVFF  02,19C
25B2:  MOVFF  01,19B
25B6:  MOVFF  00,19A
25BA:  RCALL  221C
25BC:  MOVFF  03,18E
25C0:  MOVFF  02,18D
25C4:  MOVFF  01,18C
25C8:  MOVFF  00,18B
....................          } 
25CC:  BRA    2640
25CE:  MOVLB  1
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
25D0:  CLRF   x95
25D2:  CLRF   x94
25D4:  MOVLW  20
25D6:  MOVWF  x93
25D8:  MOVLW  82
25DA:  MOVWF  x92
25DC:  MOVFF  18E,199
25E0:  MOVFF  18D,198
25E4:  MOVFF  18C,197
25E8:  MOVFF  18B,196
25EC:  MOVLB  0
25EE:  RCALL  1F90
25F0:  MOVFF  03,195
25F4:  MOVFF  02,194
25F8:  MOVFF  01,193
25FC:  MOVFF  00,192
2600:  MOVLB  1
2602:  CLRF   x97
2604:  MOVFF  190,196
2608:  MOVLB  0
260A:  RCALL  2086
260C:  BCF    FD8.1
260E:  MOVFF  195,199
2612:  MOVFF  194,198
2616:  MOVFF  193,197
261A:  MOVFF  192,196
261E:  MOVFF  03,19D
2622:  MOVFF  02,19C
2626:  MOVFF  01,19B
262A:  MOVFF  00,19A
262E:  RCALL  221C
2630:  MOVFF  03,18E
2634:  MOVFF  02,18D
2638:  MOVFF  01,18C
263C:  MOVFF  00,18B
....................          } 
....................       } 
2640:  BRA    264C
2642:  MOVLB  1
....................       else if (!skip) 
2644:  BTFSC  x8F.0
2646:  BRA    264A
....................          break; 
2648:  BRA    2664
264A:  MOVLB  0
264C:  MOVLB  1
264E:  MOVF   x91,W
2650:  INCF   x91,F
2652:  CLRF   03
2654:  ADDWF  x83,W
2656:  MOVWF  FE9
2658:  MOVF   x84,W
265A:  ADDWFC 03,W
265C:  MOVWF  FEA
265E:  MOVFF  FEF,190
2662:  BRA    24D4
....................    } 
....................  
....................    if (sign) 
2664:  BTFSS  x8F.1
2666:  BRA    269A
....................       result = -1*result; 
2668:  CLRF   x95
266A:  CLRF   x94
266C:  MOVLW  80
266E:  MOVWF  x93
2670:  MOVLW  7F
2672:  MOVWF  x92
2674:  MOVFF  18E,199
2678:  MOVFF  18D,198
267C:  MOVFF  18C,197
2680:  MOVFF  18B,196
2684:  MOVLB  0
2686:  RCALL  1F90
2688:  MOVFF  03,18E
268C:  MOVFF  02,18D
2690:  MOVFF  01,18C
2694:  MOVFF  00,18B
2698:  MOVLB  1
....................        
....................    if(endptr) 
269A:  MOVF   x85,W
269C:  IORWF  x86,W
269E:  BZ    26CE
....................    { 
....................       if (ptr) { 
26A0:  MOVF   x91,F
26A2:  BZ    26BC
....................          ptr--; 
26A4:  DECF   x91,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
26A6:  MOVFF  185,FE9
26AA:  MOVFF  186,FEA
26AE:  MOVF   x91,W
26B0:  ADDWF  x83,W
26B2:  MOVWF  FEF
26B4:  MOVLW  00
26B6:  ADDWFC x84,W
26B8:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
26BA:  BRA    26CE
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
26BC:  MOVFF  185,FE9
26C0:  MOVFF  186,FEA
26C4:  MOVFF  184,FEC
26C8:  MOVF   FED,F
26CA:  MOVFF  183,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
26CE:  MOVFF  18B,00
26D2:  MOVFF  18C,01
26D6:  MOVFF  18D,02
26DA:  MOVFF  18E,03
26DE:  MOVLB  0
26E0:  GOTO   28BE (RETURN)
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h>  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... /*------------- CONFIGURACIONES -------------*/ 
....................  
.................... #fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,PLL5,CPUDIV1,VREGEN,MCLR,USBDIV, // Fusibles 
.................... #use delay(clock=48000000) // Frecuencia de trabajo del PIC 
*
0E90:  MOVLW  01
0E92:  MOVWF  FEA
0E94:  MOVLW  91
0E96:  MOVWF  FE9
0E98:  MOVF   FEF,W
0E9A:  BZ    0EB8
0E9C:  MOVLW  0F
0E9E:  MOVWF  01
0EA0:  CLRF   00
0EA2:  DECFSZ 00,F
0EA4:  BRA    0EA2
0EA6:  DECFSZ 01,F
0EA8:  BRA    0EA0
0EAA:  MOVLW  8F
0EAC:  MOVWF  00
0EAE:  DECFSZ 00,F
0EB0:  BRA    0EAE
0EB2:  NOP   
0EB4:  DECFSZ FEF,F
0EB6:  BRA    0E9C
0EB8:  RETURN 0
0EBA:  MOVLW  01
0EBC:  MOVLB  1
0EBE:  SUBWF  x91,F
0EC0:  BNC   0EDC
0EC2:  MOVLW  01
0EC4:  MOVWF  FEA
0EC6:  MOVLW  91
0EC8:  MOVWF  FE9
0ECA:  MOVF   FEF,W
0ECC:  BZ    0EDC
0ECE:  MOVLW  02
0ED0:  MOVWF  00
0ED2:  DECFSZ 00,F
0ED4:  BRA    0ED2
0ED6:  BRA    0ED8
0ED8:  DECFSZ FEF,F
0EDA:  BRA    0ECE
0EDC:  MOVLB  0
0EDE:  RETURN 0
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7, BITS=8, PARITY=N, STOP=1, ERRORS)// Configuracion del RS232 Estándar 
*
00C2:  BTFSS  F9E.5
00C4:  BRA    00C2
00C6:  MOVFF  FAB,1D
00CA:  MOVFF  FAE,01
00CE:  BTFSS  1D.1
00D0:  BRA    00D6
00D2:  BCF    FAB.4
00D4:  BSF    FAB.4
00D6:  GOTO   0128 (RETURN)
.................... #USE FIXED_IO (b_OUTPUTS=pin_b0, pin_b1,pin_b2,pin_b3,pin_b4,pin_b5) // Puerto B como salida 
.................... #USE FIXED_IO (d_OUTPUTS=pin_d0,pin_d1,pin_d2,pin_d3,pin_d4,pin_d5)  // Puerto D como salida 
.................... #USE FIXED_IO (c_OUTPUTS=pin_c0,pin_c1,pin_c2) // C0, C1 Y C2  como salida 
.................... #use standard_io(A) // Puerto A se configura automaticamente 
....................  
.................... /*------------- DEFINICIONES -------------*/ 
....................  
.................... #define LED_J     PIN_C0 
.................... #define LED_M     PIN_C1 
.................... #define LED_S     PIN_C2 
.................... #define DIR_M1    PIN_D0 
.................... #define DIR_M2    PIN_D1 
.................... #define DIR_M3    PIN_D2 
.................... #define DIR_M4    PIN_D3 
.................... #define DIR_M5    PIN_D4 
.................... #define DIR_M6    PIN_D5 
.................... #define STEP_M1   PIN_B0 
.................... #define STEP_M2   PIN_B1 
.................... #define STEP_M3   PIN_B2 
.................... #define STEP_M4   PIN_B3 
.................... #define STEP_M5   PIN_B4 
.................... #define STEP_M6   PIN_B5 
.................... #define HOME_M1   PIN_A0 
.................... #define HOME_M2   PIN_A1 
.................... #define HOME_M3   PIN_A2 
.................... #define HOME_M4   PIN_A3 
.................... #define HOME_M5   PIN_A4 
.................... #define HOME_M6   PIN_A5 
....................  
.................... #define PRIMERO 1 
.................... #define OTRO 0 
.................... /*------------- DECLARACION DE VARIABLES -------------*/ 
....................  
.................... int const lenbuff = 50; // Longitud de buffer 
.................... int xbuff = 0x00;       // Índice: siguiente char en cbuff 
.................... char cbuff[lenbuff];    // Buffer 
.................... char rcvchar = 0x00;    // Ultimo caracter recibido 
.................... int cantCaracteres = 0; // Contador de caracteres recibidos para determinar cantidad de paquetes 
.................... int cantPaquetes = 0;   // Cantidad de paquetes recibidos 
.................... char modoOperacion = 0x00; // Almacena una letra que representa un modo de operacion 
....................  
.................... unsigned char flagComando = 0;      // Flag que indica comando disponible 
.................... unsigned char flagAsterisco = 0;    // Flag que indica que llegó el asterisco 
.................... unsigned char flagNumeral = 0;      // Flag que indica que llegó el numeral 
.................... unsigned char flagDollar = 0;       // Flag que indica que llegó el signo dollar 
.................... unsigned char flagEstirar = 0;      // Flag para iniciar la funcion estirar() 
.................... unsigned char flagEstirar2 = 0;     // Flag auxiliar   
.................... unsigned char flagFlanco[6] = {0, 0, 0, 0, 0, 0}; // Flags para tomar un paso en el flanco de subida 
.................... unsigned char flagTimer = 0;        // Flag para iniciar la interrupcion del Timer 0 
.................... unsigned char flagHome = 0;         // Flag para iniciar la funcion home() 
.................... unsigned char flagS = 0;            // Flag para indicar inicio de modo secuencia por puerto serie 
.................... unsigned char flagF = 0;            // Flag para indicar fin de modo secuencia por puerto serie 
.................... unsigned char flagArmarPaquete = 0; // Flag para iniciar la funcion armarPaquete() 
.................... unsigned char flagPasosDados = 0;   // Flag para iniciar la funcion calcularPasosDados() 
.................... unsigned char flagCrearSecuenciaInit = 0; // Flag para iniciar la funcion crearSecInit() 
.................... unsigned char flagPaquetePasosDados = 0; // Flag para armar el paquete con los pasos dados del motor 
....................  
.................... // Matriz que almacena los datos de cada motor 
.................... char motor[6][7] = { 
....................     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 
....................     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 
....................     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 
....................     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 
....................     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 
....................     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} 
.................... }; 
....................  
.................... char i = 0x00;  
.................... int j = 0; 
....................  
.................... // En modo Jog: vale 0 o 1 e indica al motor que se detenga o se mueva 
.................... // En modo Manual: almacena la cantidad de pasos que debe moverse el motor 
.................... signed int32 pasos[6] = {0, 0, 0, 0, 0, 0}; 
....................  
.................... int8 velocidad[6] = {0, 0, 0, 0, 0, 0}; // Vector que almacena los valores de las velocidades de los motores 
.................... int8 velofija[6] = {0, 0, 0, 0, 0, 0};  // Auxiliar del vetor velocidad 
.................... signed int32 contPasos[6] = {0, 0, 0, 0, 0, 0}; // Cuenta la cantidad de pasos que se mueve el motor 
.................... signed int32 pasosAnteriores[6] = {5190, 2500 , 22250, 0, 6800, 0}; 
.................... signed int32 pasosActuales[6] = {0, 0, 0, 0, 0, 0}; 
.................... signed int32 pasosDados[6] = {0, 0, 0, 0, 0, 0}; 
.................... signed int32 arrayPasos[6] = {0, 0, 0, 0, 0, 0}; 
.................... char provi[6] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}; // Auxiliar de la matriz motores 
.................... char veloprovi = 0; // Auxiliar del vector velocidad 
.................... int interrupVel = 150; // Velocidad de la interrupcion del Timer 0 
.................... int16 veloAjuste = 1000; 
.................... signed int32 pasosmax[6] = {10379, 4707 , 44501, 4500, 13593, 6400}; // Pasos maximos de cada motor 
.................... signed int32 pasosmin[6] = {0, 0 ,0, 0, 0, 0}; 
.................... char signoPasos[6] = "++++++"; 
.................... int16 pasosEstirado[6] = {5190, 2500, 22250, 0, 6800, 0}; 
....................  
.................... /*------------- DECLARACION DE FUNCIONES -------------*/ 
....................  
.................... void inicbuff(void);            // Borra buffer  
.................... void procesa_comando(void);     // Procesa el paquete recivido  
.................... void mover_motor(char nMotor);  // Mueve el motor seleccionado 
.................... void cleanAll(void);            // Reinicia las variables 
.................... void estirar(void);             // Estira el brazo 
....................  
.................... // El robot se va a home. 
.................... // primerHome = 1 -> Es el primer home del robot. Los motores hacen unos paso para atras para detectar el sensor 
.................... // primerHome = 0 -> Los siguientes home luego del primero. Los motores no hacen los pasos para atras 
.................... void home(int primerHome);       
....................                                  
.................... void crearSecInit(void);        // Crea Secuencias 
.................... void calcularPasosDados(void);  // Calcula los pasos dados del motor 
.................... void armarPaquete(void);        // Arma el paquete y lo envía por puerto serie 
....................  
.................... /*------------- FUNCIONES -------------*/ 
....................  
.................... void cleanAll(void) { 
*
0EE0:  CLRF   16
0EE2:  BTFSC  FF2.7
0EE4:  BSF    16.7
0EE6:  BCF    FF2.7
....................  
....................     inicbuff(); 
0EE8:  RCALL  0CB4
0EEA:  BTFSC  16.7
0EEC:  BSF    FF2.7
....................  
....................     for (i = 0; i < 6; i++) { 
0EEE:  CLRF   x93
0EF0:  MOVF   x93,W
0EF2:  SUBLW  05
0EF4:  BNC   0FA0
....................  
....................         pasos[i] = 0x00; 
0EF6:  MOVF   x93,W
0EF8:  MULLW  04
0EFA:  MOVF   FF3,W
0EFC:  CLRF   03
0EFE:  ADDLW  95
0F00:  MOVWF  FE9
0F02:  MOVLW  00
0F04:  ADDWFC 03,W
0F06:  MOVWF  FEA
0F08:  CLRF   FEF
0F0A:  CLRF   FEC
0F0C:  CLRF   FEC
0F0E:  CLRF   FEC
....................         velocidad[i] = 0x00; 
0F10:  CLRF   03
0F12:  MOVF   x93,W
0F14:  ADDLW  AD
0F16:  MOVWF  FE9
0F18:  MOVLW  00
0F1A:  ADDWFC 03,W
0F1C:  MOVWF  FEA
0F1E:  CLRF   FEF
....................         velofija [i] = 0x00; 
0F20:  CLRF   03
0F22:  MOVF   x93,W
0F24:  ADDLW  B3
0F26:  MOVWF  FE9
0F28:  MOVLW  00
0F2A:  ADDWFC 03,W
0F2C:  MOVWF  FEA
0F2E:  CLRF   FEF
....................         contPasos[i] = 0x00; 
0F30:  MOVF   x93,W
0F32:  MULLW  04
0F34:  MOVF   FF3,W
0F36:  CLRF   03
0F38:  ADDLW  B9
0F3A:  MOVWF  FE9
0F3C:  MOVLW  00
0F3E:  ADDWFC 03,W
0F40:  MOVWF  FEA
0F42:  CLRF   FEF
0F44:  CLRF   FEC
0F46:  CLRF   FEC
0F48:  CLRF   FEC
....................         pasosAnteriores[i] = 0x00; 
0F4A:  MOVF   x93,W
0F4C:  MULLW  04
0F4E:  MOVF   FF3,W
0F50:  CLRF   03
0F52:  ADDLW  D1
0F54:  MOVWF  FE9
0F56:  MOVLW  00
0F58:  ADDWFC 03,W
0F5A:  MOVWF  FEA
0F5C:  CLRF   FEF
0F5E:  CLRF   FEC
0F60:  CLRF   FEC
0F62:  CLRF   FEC
....................  
....................         for (j = 0; j < 6; j++) { 
0F64:  CLRF   x94
0F66:  MOVF   x94,W
0F68:  SUBLW  05
0F6A:  BNC   0F9C
....................             motor[i][j] = 0x00; 
0F6C:  MOVF   x93,W
0F6E:  MULLW  07
0F70:  MOVF   FF3,W
0F72:  MOVLB  1
0F74:  CLRF   x91
0F76:  MOVWF  x90
0F78:  CLRF   03
0F7A:  MOVLB  0
0F7C:  MOVF   x94,W
0F7E:  MOVLB  1
0F80:  ADDWF  x90,W
0F82:  MOVWF  01
0F84:  MOVF   x91,W
0F86:  ADDWFC 03,F
0F88:  MOVF   01,W
0F8A:  ADDLW  69
0F8C:  MOVWF  FE9
0F8E:  MOVLW  00
0F90:  ADDWFC 03,W
0F92:  MOVWF  FEA
0F94:  CLRF   FEF
0F96:  MOVLB  0
0F98:  INCF   x94,F
0F9A:  BRA    0F66
....................         } 
0F9C:  INCF   x93,F
0F9E:  BRA    0EF0
....................  
....................     } 
0FA0:  GOTO   13C2 (RETURN)
....................  
.................... } 
....................  
.................... void home(int primerHome) { 
....................  
....................     disable_interrupts(INT_RDA); 
0FA4:  BCF    F9D.5
....................  
....................     int primeraVueltaMotor1 = 1; 
....................     int primeraVueltaMotor2 = 1; 
....................     int primeraVueltaMotor3 = 1; 
....................     int primeraVueltaMotor4 = 1; 
....................     int primeraVueltaMotor5 = 1; 
....................     int primeraVueltaMotor6 = 1; 
....................  
....................     int motor1Activo = 0; //Variables que indican si se movió un motor. Esto es para agregar un retardo entre articulaciones 
....................     int motor2Activo = 0; //solo si la articulacion anterior se movió 
....................     int motor3Activo = 0; 
....................     int motor4Activo = 0; 
....................     int motor5Activo = 0; 
....................     int motor6Activo = 0; 
0FA6:  MOVLW  01
0FA8:  MOVLB  1
0FAA:  MOVWF  x7E
0FAC:  MOVWF  x7F
0FAE:  MOVWF  x80
0FB0:  MOVWF  x81
0FB2:  MOVWF  x82
0FB4:  MOVWF  x83
0FB6:  CLRF   x84
0FB8:  CLRF   x85
0FBA:  CLRF   x86
0FBC:  CLRF   x87
0FBE:  CLRF   x88
0FC0:  CLRF   x89
....................  
....................     while ((input(HOME_M1) == 1) || (input(HOME_M2)) == 1 || (input(HOME_M3)) == 1 || (input(HOME_M4)) == 1 || (input(HOME_M5)) == 1 || (input(HOME_M6)) == 1) { 
0FC2:  BSF    F92.0
0FC4:  BTFSC  F80.0
0FC6:  BRA    0FE6
0FC8:  BSF    F92.1
0FCA:  BTFSC  F80.1
0FCC:  BRA    0FE6
0FCE:  BSF    F92.2
0FD0:  BTFSC  F80.2
0FD2:  BRA    0FE6
0FD4:  BSF    F92.3
0FD6:  BTFSC  F80.3
0FD8:  BRA    0FE6
0FDA:  BSF    F92.4
0FDC:  BTFSC  F80.4
0FDE:  BRA    0FE6
0FE0:  BSF    F92.5
0FE2:  BTFSS  F80.5
0FE4:  BRA    13BE
....................  
....................         if (input(HOME_M6) == 1) { 
0FE6:  BSF    F92.5
0FE8:  BTFSS  F80.5
0FEA:  BRA    1078
....................              
....................             veloAjuste = 1000; 
0FEC:  MOVLW  03
0FEE:  MOVWF  x3A
0FF0:  MOVLW  E8
0FF2:  MOVWF  x39
....................             motor6Activo = 1; 
0FF4:  MOVLW  01
0FF6:  MOVWF  x89
....................              
....................             if (primerHome == 1) { 
0FF8:  DECFSZ x7D,W
0FFA:  BRA    1052
....................                 if (primeraVueltaMotor6 == 1) { 
0FFC:  DECFSZ x83,W
0FFE:  BRA    1052
....................                     for (int contadorHome = 0; contadorHome < 100; contadorHome++) { 
1000:  CLRF   x8A
1002:  MOVF   x8A,W
1004:  SUBLW  63
1006:  BNC   1050
....................                         output_low(DIR_M6); 
1008:  MOVLW  C0
100A:  MOVWF  F95
100C:  BCF    F8C.5
....................                         output_high(STEP_M6); 
100E:  MOVWF  F93
1010:  BSF    F8A.5
....................                         delay_us(5); 
1012:  MOVLW  13
1014:  MOVWF  00
1016:  DECFSZ 00,F
1018:  BRA    1016
101A:  BRA    101C
....................                         output_low(STEP_M6); 
101C:  MOVLW  C0
101E:  MOVWF  F93
1020:  BCF    F8A.5
....................                         delay_us(5); 
1022:  MOVLW  13
1024:  MOVWF  00
1026:  DECFSZ 00,F
1028:  BRA    1026
102A:  BRA    102C
....................                         delay_us(veloAjuste); 
102C:  MOVFF  13A,190
1030:  INCF   x90,F
1032:  DECF   x90,F
1034:  BTFSC  FD8.2
1036:  BRA    1042
1038:  SETF   x91
103A:  MOVLB  0
103C:  RCALL  0EBA
103E:  MOVLB  1
1040:  BRA    1032
1042:  MOVFF  139,191
1046:  MOVLB  0
1048:  RCALL  0EBA
104A:  MOVLB  1
104C:  INCF   x8A,F
104E:  BRA    1002
....................                     } 
....................                     primeraVueltaMotor6 = 0; 
1050:  CLRF   x83
....................                 } 
....................             } 
....................  
....................             output_high(DIR_M6); 
1052:  MOVLW  C0
1054:  MOVWF  F95
1056:  BSF    F8C.5
....................             output_high(STEP_M6); 
1058:  MOVWF  F93
105A:  BSF    F8A.5
....................             delay_us(5); 
105C:  MOVLW  13
105E:  MOVWF  00
1060:  DECFSZ 00,F
1062:  BRA    1060
1064:  BRA    1066
....................             output_low(STEP_M6); 
1066:  MOVLW  C0
1068:  MOVWF  F93
106A:  BCF    F8A.5
....................             delay_us(5); 
106C:  MOVLW  13
106E:  MOVWF  00
1070:  DECFSZ 00,F
1072:  BRA    1070
1074:  BRA    1076
....................  
....................         } else if (input(HOME_M5) == 1) { 
1076:  BRA    139C
1078:  BSF    F92.4
107A:  BTFSS  F80.4
107C:  BRA    1122
....................              
....................             veloAjuste = 800; 
107E:  MOVLW  03
1080:  MOVWF  x3A
1082:  MOVLW  20
1084:  MOVWF  x39
....................              
....................             if (motor6Activo == 1) { 
1086:  DECFSZ x89,W
1088:  BRA    10A2
....................                 delay_ms(500); 
108A:  MOVLW  02
108C:  MOVWF  x90
108E:  MOVLW  FA
1090:  MOVWF  x91
1092:  MOVLB  0
1094:  RCALL  0E90
1096:  MOVLB  1
1098:  DECFSZ x90,F
109A:  BRA    108E
....................                 motor5Activo = 1; 
109C:  MOVLW  01
109E:  MOVWF  x88
....................                 motor6Activo = 0; 
10A0:  CLRF   x89
....................             } 
....................              
....................             if (primerHome == 1) { 
10A2:  DECFSZ x7D,W
10A4:  BRA    10FC
....................                 if (primeraVueltaMotor5 == 1) { 
10A6:  DECFSZ x82,W
10A8:  BRA    10FC
....................                     for (int contadorHome = 0; contadorHome < 100; contadorHome++) { 
10AA:  CLRF   x8B
10AC:  MOVF   x8B,W
10AE:  SUBLW  63
10B0:  BNC   10FA
....................                         output_low(DIR_M5); 
10B2:  MOVLW  C0
10B4:  MOVWF  F95
10B6:  BCF    F8C.4
....................                         output_high(STEP_M5); 
10B8:  MOVWF  F93
10BA:  BSF    F8A.4
....................                         delay_us(5); 
10BC:  MOVLW  13
10BE:  MOVWF  00
10C0:  DECFSZ 00,F
10C2:  BRA    10C0
10C4:  BRA    10C6
....................                         output_low(STEP_M5); 
10C6:  MOVLW  C0
10C8:  MOVWF  F93
10CA:  BCF    F8A.4
....................                         delay_us(5); 
10CC:  MOVLW  13
10CE:  MOVWF  00
10D0:  DECFSZ 00,F
10D2:  BRA    10D0
10D4:  BRA    10D6
....................                         delay_us(veloAjuste); 
10D6:  MOVFF  13A,190
10DA:  INCF   x90,F
10DC:  DECF   x90,F
10DE:  BTFSC  FD8.2
10E0:  BRA    10EC
10E2:  SETF   x91
10E4:  MOVLB  0
10E6:  RCALL  0EBA
10E8:  MOVLB  1
10EA:  BRA    10DC
10EC:  MOVFF  139,191
10F0:  MOVLB  0
10F2:  RCALL  0EBA
10F4:  MOVLB  1
10F6:  INCF   x8B,F
10F8:  BRA    10AC
....................                     } 
....................                     primeraVueltaMotor5 = 0; 
10FA:  CLRF   x82
....................                 } 
....................             } 
....................  
....................             output_high(DIR_M5); 
10FC:  MOVLW  C0
10FE:  MOVWF  F95
1100:  BSF    F8C.4
....................             output_high(STEP_M5); 
1102:  MOVWF  F93
1104:  BSF    F8A.4
....................             delay_us(5); 
1106:  MOVLW  13
1108:  MOVWF  00
110A:  DECFSZ 00,F
110C:  BRA    110A
110E:  BRA    1110
....................             output_low(STEP_M5); 
1110:  MOVLW  C0
1112:  MOVWF  F93
1114:  BCF    F8A.4
....................             delay_us(5); 
1116:  MOVLW  13
1118:  MOVWF  00
111A:  DECFSZ 00,F
111C:  BRA    111A
111E:  BRA    1120
....................  
....................         } else if (input(HOME_M4) == 1) { 
1120:  BRA    139C
1122:  BSF    F92.3
1124:  BTFSS  F80.3
1126:  BRA    11CC
....................              
....................             veloAjuste = 6000; 
1128:  MOVLW  17
112A:  MOVWF  x3A
112C:  MOVLW  70
112E:  MOVWF  x39
....................              
....................             if (motor5Activo == 1) { 
1130:  DECFSZ x88,W
1132:  BRA    114C
....................                 delay_ms(500); 
1134:  MOVLW  02
1136:  MOVWF  x90
1138:  MOVLW  FA
113A:  MOVWF  x91
113C:  MOVLB  0
113E:  RCALL  0E90
1140:  MOVLB  1
1142:  DECFSZ x90,F
1144:  BRA    1138
....................                 motor4Activo = 1; 
1146:  MOVLW  01
1148:  MOVWF  x87
....................                 motor5Activo = 0; 
114A:  CLRF   x88
....................             } 
....................              
....................             if (primerHome == 1) { 
114C:  DECFSZ x7D,W
114E:  BRA    11A6
....................                 if (primeraVueltaMotor4 == 1) { 
1150:  DECFSZ x81,W
1152:  BRA    11A6
....................                     for (int contadorHome = 0; contadorHome < 100; contadorHome++) { 
1154:  CLRF   x8C
1156:  MOVF   x8C,W
1158:  SUBLW  63
115A:  BNC   11A4
....................                         output_low(DIR_M4); 
115C:  MOVLW  C0
115E:  MOVWF  F95
1160:  BCF    F8C.3
....................                         output_high(STEP_M4); 
1162:  MOVWF  F93
1164:  BSF    F8A.3
....................                         delay_us(5); 
1166:  MOVLW  13
1168:  MOVWF  00
116A:  DECFSZ 00,F
116C:  BRA    116A
116E:  BRA    1170
....................                         output_low(STEP_M4); 
1170:  MOVLW  C0
1172:  MOVWF  F93
1174:  BCF    F8A.3
....................                         delay_us(5); 
1176:  MOVLW  13
1178:  MOVWF  00
117A:  DECFSZ 00,F
117C:  BRA    117A
117E:  BRA    1180
....................                         delay_us(veloAjuste); 
1180:  MOVFF  13A,190
1184:  INCF   x90,F
1186:  DECF   x90,F
1188:  BTFSC  FD8.2
118A:  BRA    1196
118C:  SETF   x91
118E:  MOVLB  0
1190:  RCALL  0EBA
1192:  MOVLB  1
1194:  BRA    1186
1196:  MOVFF  139,191
119A:  MOVLB  0
119C:  RCALL  0EBA
119E:  MOVLB  1
11A0:  INCF   x8C,F
11A2:  BRA    1156
....................                     } 
....................                     primeraVueltaMotor4 = 0; 
11A4:  CLRF   x81
....................                 } 
....................             } 
....................  
....................             output_high(DIR_M4); 
11A6:  MOVLW  C0
11A8:  MOVWF  F95
11AA:  BSF    F8C.3
....................             output_high(STEP_M4); 
11AC:  MOVWF  F93
11AE:  BSF    F8A.3
....................             delay_us(5); 
11B0:  MOVLW  13
11B2:  MOVWF  00
11B4:  DECFSZ 00,F
11B6:  BRA    11B4
11B8:  BRA    11BA
....................             output_low(STEP_M4); 
11BA:  MOVLW  C0
11BC:  MOVWF  F93
11BE:  BCF    F8A.3
....................             delay_us(5); 
11C0:  MOVLW  13
11C2:  MOVWF  00
11C4:  DECFSZ 00,F
11C6:  BRA    11C4
11C8:  BRA    11CA
....................  
....................         } else if (input(HOME_M3) == 1) { 
11CA:  BRA    139C
11CC:  BSF    F92.2
11CE:  BTFSS  F80.2
11D0:  BRA    1276
....................              
....................             veloAjuste = 400; 
11D2:  MOVLW  01
11D4:  MOVWF  x3A
11D6:  MOVLW  90
11D8:  MOVWF  x39
....................              
....................             if (motor4Activo == 1) { 
11DA:  DECFSZ x87,W
11DC:  BRA    11F6
....................                 delay_ms(1000); 
11DE:  MOVLW  04
11E0:  MOVWF  x90
11E2:  MOVLW  FA
11E4:  MOVWF  x91
11E6:  MOVLB  0
11E8:  RCALL  0E90
11EA:  MOVLB  1
11EC:  DECFSZ x90,F
11EE:  BRA    11E2
....................                 motor3Activo = 1; 
11F0:  MOVLW  01
11F2:  MOVWF  x86
....................                 motor4Activo = 0; 
11F4:  CLRF   x87
....................             } 
....................              
....................             if (primerHome == 1) { 
11F6:  DECFSZ x7D,W
11F8:  BRA    1250
....................                 if (primeraVueltaMotor3 == 1) { 
11FA:  DECFSZ x80,W
11FC:  BRA    1250
....................                     for (int contadorHome = 0; contadorHome < 100; contadorHome++) { 
11FE:  CLRF   x8D
1200:  MOVF   x8D,W
1202:  SUBLW  63
1204:  BNC   124E
....................                         output_low(DIR_M3); 
1206:  MOVLW  C0
1208:  MOVWF  F95
120A:  BCF    F8C.2
....................                         output_high(STEP_M3); 
120C:  MOVWF  F93
120E:  BSF    F8A.2
....................                         delay_us(5); 
1210:  MOVLW  13
1212:  MOVWF  00
1214:  DECFSZ 00,F
1216:  BRA    1214
1218:  BRA    121A
....................                         output_low(STEP_M3); 
121A:  MOVLW  C0
121C:  MOVWF  F93
121E:  BCF    F8A.2
....................                         delay_us(5); 
1220:  MOVLW  13
1222:  MOVWF  00
1224:  DECFSZ 00,F
1226:  BRA    1224
1228:  BRA    122A
....................                         delay_us(veloAjuste); 
122A:  MOVFF  13A,190
122E:  INCF   x90,F
1230:  DECF   x90,F
1232:  BTFSC  FD8.2
1234:  BRA    1240
1236:  SETF   x91
1238:  MOVLB  0
123A:  RCALL  0EBA
123C:  MOVLB  1
123E:  BRA    1230
1240:  MOVFF  139,191
1244:  MOVLB  0
1246:  RCALL  0EBA
1248:  MOVLB  1
124A:  INCF   x8D,F
124C:  BRA    1200
....................                     } 
....................                     primeraVueltaMotor3 = 0; 
124E:  CLRF   x80
....................                 } 
....................             } 
....................  
....................             output_high(DIR_M3); 
1250:  MOVLW  C0
1252:  MOVWF  F95
1254:  BSF    F8C.2
....................             output_high(STEP_M3); 
1256:  MOVWF  F93
1258:  BSF    F8A.2
....................             delay_us(5); 
125A:  MOVLW  13
125C:  MOVWF  00
125E:  DECFSZ 00,F
1260:  BRA    125E
1262:  BRA    1264
....................             output_low(STEP_M3); 
1264:  MOVLW  C0
1266:  MOVWF  F93
1268:  BCF    F8A.2
....................             delay_us(5); 
126A:  MOVLW  13
126C:  MOVWF  00
126E:  DECFSZ 00,F
1270:  BRA    126E
1272:  BRA    1274
....................  
....................         } else if (input(HOME_M2) == 1) { 
1274:  BRA    139C
1276:  BSF    F92.1
1278:  BTFSS  F80.1
127A:  BRA    130A
....................              
....................             veloAjuste = 3200; 
127C:  MOVLW  0C
127E:  MOVWF  x3A
1280:  MOVLW  80
1282:  MOVWF  x39
....................             //veloAjuste = 700; 
....................              
....................             if (motor3Activo == 1) { 
1284:  DECFSZ x86,W
1286:  BRA    12A0
....................                 delay_ms(500); 
1288:  MOVLW  02
128A:  MOVWF  x90
128C:  MOVLW  FA
128E:  MOVWF  x91
1290:  MOVLB  0
1292:  RCALL  0E90
1294:  MOVLB  1
1296:  DECFSZ x90,F
1298:  BRA    128C
....................                 motor2Activo = 1; 
129A:  MOVLW  01
129C:  MOVWF  x85
....................                 motor3Activo = 0; 
129E:  CLRF   x86
....................             } 
....................              
....................             if (primerHome == 1) { 
12A0:  DECFSZ x7D,W
12A2:  BRA    12E4
....................                 if (primeraVueltaMotor2 == 1) { 
12A4:  DECFSZ x7F,W
12A6:  BRA    12E4
....................                     for (int contadorHome = 0; contadorHome < 100; contadorHome++) { 
12A8:  CLRF   x8E
12AA:  MOVF   x8E,W
12AC:  SUBLW  63
12AE:  BNC   12E2
....................                         output_low(DIR_M2); 
12B0:  MOVLW  C0
12B2:  MOVWF  F95
12B4:  BCF    F8C.1
....................                         output_high(STEP_M2); 
12B6:  MOVWF  F93
12B8:  BSF    F8A.1
....................                         delay_us(5); 
12BA:  MOVLW  13
12BC:  MOVWF  00
12BE:  DECFSZ 00,F
12C0:  BRA    12BE
12C2:  BRA    12C4
....................                         output_low(STEP_M2); 
12C4:  MOVLW  C0
12C6:  MOVWF  F93
12C8:  BCF    F8A.1
....................                         delay_us(5); 
12CA:  MOVLW  13
12CC:  MOVWF  00
12CE:  DECFSZ 00,F
12D0:  BRA    12CE
12D2:  BRA    12D4
....................                         delay_us(7000); 
12D4:  MOVLW  07
12D6:  MOVWF  x91
12D8:  MOVLB  0
12DA:  RCALL  0E90
12DC:  MOVLB  1
12DE:  INCF   x8E,F
12E0:  BRA    12AA
....................                         //delay_us(1750); 
....................                     } 
....................                     primeraVueltaMotor2 = 0; 
12E2:  CLRF   x7F
....................                 } 
....................             } 
....................  
....................             output_high(DIR_M2); 
12E4:  MOVLW  C0
12E6:  MOVWF  F95
12E8:  BSF    F8C.1
....................             output_high(STEP_M2); 
12EA:  MOVWF  F93
12EC:  BSF    F8A.1
....................             delay_us(5); 
12EE:  MOVLW  13
12F0:  MOVWF  00
12F2:  DECFSZ 00,F
12F4:  BRA    12F2
12F6:  BRA    12F8
....................             output_low(STEP_M2); 
12F8:  MOVLW  C0
12FA:  MOVWF  F93
12FC:  BCF    F8A.1
....................             delay_us(5); 
12FE:  MOVLW  13
1300:  MOVWF  00
1302:  DECFSZ 00,F
1304:  BRA    1302
1306:  BRA    1308
....................  
....................         } else if (input(HOME_M1) == 1) { 
1308:  BRA    139C
130A:  BSF    F92.0
130C:  BTFSS  F80.0
130E:  BRA    139C
....................              
....................             veloAjuste = 1000; 
1310:  MOVLW  03
1312:  MOVWF  x3A
1314:  MOVLW  E8
1316:  MOVWF  x39
....................              
....................             if (motor2Activo == 1) { 
1318:  DECFSZ x85,W
131A:  BRA    1334
....................                 delay_ms(500); 
131C:  MOVLW  02
131E:  MOVWF  x90
1320:  MOVLW  FA
1322:  MOVWF  x91
1324:  MOVLB  0
1326:  RCALL  0E90
1328:  MOVLB  1
132A:  DECFSZ x90,F
132C:  BRA    1320
....................                 motor1Activo = 1; 
132E:  MOVLW  01
1330:  MOVWF  x84
....................                 motor2Activo = 0; 
1332:  CLRF   x85
....................             } 
....................              
....................             if (primerHome == 1) { 
1334:  DECFSZ x7D,W
1336:  BRA    1378
....................                 if (primeraVueltaMotor1 == 1) { 
1338:  DECFSZ x7E,W
133A:  BRA    1378
....................                     for (int contadorHome = 0; contadorHome < 150; contadorHome++) { 
133C:  CLRF   x8F
133E:  MOVF   x8F,W
1340:  SUBLW  95
1342:  BNC   1376
....................                         output_low(DIR_M1); 
1344:  MOVLW  C0
1346:  MOVWF  F95
1348:  BCF    F8C.0
....................                         output_high(STEP_M1); 
134A:  MOVWF  F93
134C:  BSF    F8A.0
....................                         delay_us(5); 
134E:  MOVLW  13
1350:  MOVWF  00
1352:  DECFSZ 00,F
1354:  BRA    1352
1356:  BRA    1358
....................                         output_low(STEP_M1); 
1358:  MOVLW  C0
135A:  MOVWF  F93
135C:  BCF    F8A.0
....................                         delay_us(5); 
135E:  MOVLW  13
1360:  MOVWF  00
1362:  DECFSZ 00,F
1364:  BRA    1362
1366:  BRA    1368
....................                         delay_us(3000); 
1368:  MOVLW  03
136A:  MOVWF  x91
136C:  MOVLB  0
136E:  RCALL  0E90
1370:  MOVLB  1
1372:  INCF   x8F,F
1374:  BRA    133E
....................                     } 
....................                     primeraVueltaMotor1 = 0; 
1376:  CLRF   x7E
....................                 } 
....................             } 
....................              
....................             output_high(DIR_M1); 
1378:  MOVLW  C0
137A:  MOVWF  F95
137C:  BSF    F8C.0
....................             output_high(STEP_M1); 
137E:  MOVWF  F93
1380:  BSF    F8A.0
....................             delay_us(5); 
1382:  MOVLW  13
1384:  MOVWF  00
1386:  DECFSZ 00,F
1388:  BRA    1386
138A:  BRA    138C
....................             output_low(STEP_M1); 
138C:  MOVLW  C0
138E:  MOVWF  F93
1390:  BCF    F8A.0
....................             delay_us(5); 
1392:  MOVLW  13
1394:  MOVWF  00
1396:  DECFSZ 00,F
1398:  BRA    1396
139A:  BRA    139C
....................  
....................         } 
....................  
....................         delay_us(veloAjuste); 
139C:  MOVFF  13A,190
13A0:  INCF   x90,F
13A2:  DECF   x90,F
13A4:  BTFSC  FD8.2
13A6:  BRA    13B2
13A8:  SETF   x91
13AA:  MOVLB  0
13AC:  RCALL  0EBA
13AE:  MOVLB  1
13B0:  BRA    13A2
13B2:  MOVFF  139,191
13B6:  MOVLB  0
13B8:  RCALL  0EBA
13BA:  MOVLB  1
13BC:  BRA    0FC2
....................  
....................     } 
....................  
....................     cleanAll(); 
13BE:  MOVLB  0
13C0:  BRA    0EE0
....................     enable_interrupts(INT_RDA); 
13C2:  BSF    F9D.5
13C4:  RETURN 0
....................  
.................... } 
....................  
.................... void mover_motor(char nMotor) { 
....................  
....................     unsigned int STEP_MOTOR[6] = {STEP_M1, STEP_M2, STEP_M3, STEP_M4, STEP_M5, STEP_M6}; 
*
0316:  MOVLW  08
0318:  MOVLB  1
031A:  MOVWF  xE3
031C:  MOVLW  09
031E:  MOVWF  xE4
0320:  MOVLW  0A
0322:  MOVWF  xE5
0324:  MOVLW  0B
0326:  MOVWF  xE6
0328:  MOVLW  0C
032A:  MOVWF  xE7
032C:  MOVLW  0D
032E:  MOVWF  xE8
....................     unsigned int DIR_MOTOR[6] = {DIR_M1, DIR_M2, DIR_M3, DIR_M4, DIR_M5, DIR_M6}; 
0330:  MOVLW  18
0332:  MOVWF  xE9
0334:  MOVLW  19
0336:  MOVWF  xEA
0338:  MOVLW  1A
033A:  MOVWF  xEB
033C:  MOVLW  1B
033E:  MOVWF  xEC
0340:  MOVLW  1C
0342:  MOVWF  xED
0344:  MOVLW  1D
0346:  MOVWF  xEE
....................  
....................     velocidad[nMotor] = velocidad[nMotor] - 1; 
0348:  CLRF   03
034A:  MOVF   xE2,W
034C:  ADDLW  AD
034E:  MOVWF  01
0350:  MOVLW  00
0352:  ADDWFC 03,F
0354:  MOVFF  03,1F0
0358:  CLRF   03
035A:  MOVF   xE2,W
035C:  ADDLW  AD
035E:  MOVWF  FE9
0360:  MOVLW  00
0362:  ADDWFC 03,W
0364:  MOVWF  FEA
0366:  MOVLW  01
0368:  SUBWF  FEF,W
036A:  MOVFF  1F0,FEA
036E:  MOVFF  01,FE9
0372:  MOVWF  FEF
....................    
....................     if (velocidad[nMotor] == 0 && pasos[nMotor] != 0) { 
0374:  CLRF   03
0376:  MOVF   xE2,W
0378:  ADDLW  AD
037A:  MOVWF  FE9
037C:  MOVLW  00
037E:  ADDWFC 03,W
0380:  MOVWF  FEA
0382:  MOVF   FEF,F
0384:  BTFSS  FD8.2
0386:  GOTO   0C40
038A:  MOVF   xE2,W
038C:  MULLW  04
038E:  MOVF   FF3,W
0390:  CLRF   03
0392:  ADDLW  95
0394:  MOVWF  FE9
0396:  MOVLW  00
0398:  ADDWFC 03,W
039A:  MOVWF  FEA
039C:  MOVFF  FEF,1EF
03A0:  MOVFF  FEC,1F0
03A4:  MOVFF  FEC,1F1
03A8:  MOVFF  FEC,1F2
03AC:  MOVF   xEF,F
03AE:  BNZ   03C0
03B0:  MOVF   xF0,F
03B2:  BNZ   03C0
03B4:  MOVF   xF1,F
03B6:  BNZ   03C0
03B8:  MOVF   xF2,F
03BA:  BTFSC  FD8.2
03BC:  GOTO   0C40
....................  
....................         //Direccion 
....................         if (pasos[nMotor] > 0) { 
03C0:  MOVF   xE2,W
03C2:  MULLW  04
03C4:  MOVF   FF3,W
03C6:  CLRF   03
03C8:  ADDLW  95
03CA:  MOVWF  FE9
03CC:  MOVLW  00
03CE:  ADDWFC 03,W
03D0:  MOVWF  FEA
03D2:  MOVFF  FEF,1EF
03D6:  MOVFF  FEC,1F0
03DA:  MOVFF  FEC,1F1
03DE:  MOVFF  FEC,1F2
03E2:  BTFSC  xF2.7
03E4:  BRA    0434
03E6:  MOVF   xF2,F
03E8:  BNZ   03F8
03EA:  MOVF   xF1,F
03EC:  BNZ   03F8
03EE:  MOVF   xF0,F
03F0:  BNZ   03F8
03F2:  MOVF   xEF,W
03F4:  SUBLW  00
03F6:  BC    0434
....................             output_low(DIR_MOTOR[nMotor]); 
03F8:  CLRF   03
03FA:  MOVF   xE2,W
03FC:  ADDLW  E9
03FE:  MOVWF  FE9
0400:  MOVLW  01
0402:  ADDWFC 03,W
0404:  MOVWF  FEA
0406:  MOVFF  FEF,1EF
040A:  MOVFF  1EF,1F0
040E:  CLRF   xF1
0410:  MOVLW  0F
0412:  MOVWF  xF3
0414:  MOVLW  89
0416:  MOVWF  xF2
0418:  MOVLB  0
041A:  RCALL  02A2
041C:  MOVFF  1EF,1F0
0420:  MOVLB  1
0422:  CLRF   xF1
0424:  MOVLW  0F
0426:  MOVWF  xF3
0428:  MOVLW  92
042A:  MOVWF  xF2
042C:  MOVLB  0
042E:  RCALL  02A2
....................         } else output_high(DIR_MOTOR[nMotor]); 
0430:  BRA    046E
0432:  MOVLB  1
0434:  CLRF   03
0436:  MOVF   xE2,W
0438:  ADDLW  E9
043A:  MOVWF  FE9
043C:  MOVLW  01
043E:  ADDWFC 03,W
0440:  MOVWF  FEA
0442:  MOVFF  FEF,1EF
0446:  MOVFF  1EF,1F0
044A:  MOVLW  01
044C:  MOVWF  xF1
044E:  MOVLW  0F
0450:  MOVWF  xF3
0452:  MOVLW  89
0454:  MOVWF  xF2
0456:  MOVLB  0
0458:  RCALL  02A2
045A:  MOVFF  1EF,1F0
045E:  MOVLB  1
0460:  CLRF   xF1
0462:  MOVLW  0F
0464:  MOVWF  xF3
0466:  MOVLW  92
0468:  MOVWF  xF2
046A:  MOVLB  0
046C:  RCALL  02A2
....................  
....................         if (pasosmin[nMotor] < contPasos[nMotor] && contPasos[nMotor] < pasosmax[nMotor]) { 
046E:  MOVLB  1
0470:  MOVF   xE2,W
0472:  MULLW  04
0474:  MOVF   FF3,W
0476:  CLRF   03
0478:  ADDLW  53
047A:  MOVWF  FE9
047C:  MOVLW  01
047E:  ADDWFC 03,W
0480:  MOVWF  FEA
0482:  MOVFF  FEF,1EF
0486:  MOVFF  FEC,1F0
048A:  MOVFF  FEC,1F1
048E:  MOVFF  FEC,1F2
0492:  MOVF   xE2,W
0494:  MULLW  04
0496:  MOVF   FF3,W
0498:  CLRF   03
049A:  ADDLW  B9
049C:  MOVWF  FE9
049E:  MOVLW  00
04A0:  ADDWFC 03,W
04A2:  MOVWF  FEA
04A4:  MOVFF  FEF,00
04A8:  MOVFF  FEC,01
04AC:  MOVFF  FEC,02
04B0:  MOVFF  FEC,03
04B4:  BTFSS  xF2.7
04B6:  BRA    04BE
04B8:  BTFSS  03.7
04BA:  BRA    04E8
04BC:  BRA    04C2
04BE:  BTFSC  03.7
04C0:  BRA    0818
04C2:  MOVF   xF2,W
04C4:  SUBWF  03,W
04C6:  BTFSS  FD8.0
04C8:  BRA    0818
04CA:  BNZ   04E8
04CC:  MOVF   xF1,W
04CE:  SUBWF  02,W
04D0:  BTFSS  FD8.0
04D2:  BRA    0818
04D4:  BNZ   04E8
04D6:  MOVF   xF0,W
04D8:  SUBWF  01,W
04DA:  BTFSS  FD8.0
04DC:  BRA    0818
04DE:  BNZ   04E8
04E0:  MOVF   00,W
04E2:  SUBWF  xEF,W
04E4:  BTFSC  FD8.0
04E6:  BRA    0818
04E8:  MOVF   xE2,W
04EA:  MULLW  04
04EC:  MOVF   FF3,W
04EE:  CLRF   03
04F0:  ADDLW  B9
04F2:  MOVWF  FE9
04F4:  MOVLW  00
04F6:  ADDWFC 03,W
04F8:  MOVWF  FEA
04FA:  MOVFF  FEF,1EF
04FE:  MOVFF  FEC,1F0
0502:  MOVFF  FEC,1F1
0506:  MOVFF  FEC,1F2
050A:  MOVF   xE2,W
050C:  MULLW  04
050E:  MOVF   FF3,W
0510:  CLRF   03
0512:  ADDLW  3B
0514:  MOVWF  FE9
0516:  MOVLW  01
0518:  ADDWFC 03,W
051A:  MOVWF  FEA
051C:  MOVFF  FEF,00
0520:  MOVFF  FEC,01
0524:  MOVFF  FEC,02
0528:  MOVFF  FEC,03
052C:  BTFSS  xF2.7
052E:  BRA    0536
0530:  BTFSS  03.7
0532:  BRA    0560
0534:  BRA    053A
0536:  BTFSC  03.7
0538:  BRA    0818
053A:  MOVF   xF2,W
053C:  SUBWF  03,W
053E:  BTFSS  FD8.0
0540:  BRA    0818
0542:  BNZ   0560
0544:  MOVF   xF1,W
0546:  SUBWF  02,W
0548:  BTFSS  FD8.0
054A:  BRA    0818
054C:  BNZ   0560
054E:  MOVF   xF0,W
0550:  SUBWF  01,W
0552:  BTFSS  FD8.0
0554:  BRA    0818
0556:  BNZ   0560
0558:  MOVF   00,W
055A:  SUBWF  xEF,W
055C:  BTFSC  FD8.0
055E:  BRA    0818
....................  
....................             //////////PASO///////////           
....................             output_toggle(STEP_MOTOR[nMotor]); 
0560:  CLRF   03
0562:  MOVF   xE2,W
0564:  ADDLW  E3
0566:  MOVWF  FE9
0568:  MOVLW  01
056A:  ADDWFC 03,W
056C:  MOVWF  FEA
056E:  MOVFF  FEF,1EF
0572:  MOVFF  1EF,1F0
0576:  MOVLW  0F
0578:  MOVWF  xF2
057A:  MOVLW  80
057C:  MOVWF  xF1
057E:  MOVLB  0
0580:  RCALL  02E4
0582:  MOVLW  00
0584:  BTFSS  01.0
0586:  MOVLW  01
0588:  MOVFF  1EF,1F0
058C:  MOVLB  1
058E:  MOVWF  xF1
0590:  MOVLW  0F
0592:  MOVWF  xF3
0594:  MOVLW  89
0596:  MOVWF  xF2
0598:  MOVLB  0
059A:  RCALL  02A2
059C:  MOVFF  1EF,1F0
05A0:  MOVLB  1
05A2:  CLRF   xF1
05A4:  MOVLW  0F
05A6:  MOVWF  xF3
05A8:  MOVLW  92
05AA:  MOVWF  xF2
05AC:  MOVLB  0
05AE:  RCALL  02A2
....................  
....................             if (flagFlanco[nMotor] == 0) { 
05B0:  CLRF   03
05B2:  MOVLB  1
05B4:  MOVF   xE2,W
05B6:  ADDLW  5B
05B8:  MOVWF  FE9
05BA:  MOVLW  00
05BC:  ADDWFC 03,W
05BE:  MOVWF  FEA
05C0:  MOVF   FEF,F
05C2:  BTFSS  FD8.2
05C4:  BRA    0806
....................                 flagFlanco[nMotor] = 1; 
05C6:  CLRF   03
05C8:  MOVF   xE2,W
05CA:  ADDLW  5B
05CC:  MOVWF  FE9
05CE:  MOVLW  00
05D0:  ADDWFC 03,W
05D2:  MOVWF  FEA
05D4:  MOVLW  01
05D6:  MOVWF  FEF
....................                 if (pasos[nMotor] > 0) { 
05D8:  MOVF   xE2,W
05DA:  MULLW  04
05DC:  MOVF   FF3,W
05DE:  CLRF   03
05E0:  ADDLW  95
05E2:  MOVWF  FE9
05E4:  MOVLW  00
05E6:  ADDWFC 03,W
05E8:  MOVWF  FEA
05EA:  MOVFF  FEF,1EF
05EE:  MOVFF  FEC,1F0
05F2:  MOVFF  FEC,1F1
05F6:  MOVFF  FEC,1F2
05FA:  BTFSC  xF2.7
05FC:  BRA    0728
05FE:  MOVF   xF2,F
0600:  BNZ   0612
0602:  MOVF   xF1,F
0604:  BNZ   0612
0606:  MOVF   xF0,F
0608:  BNZ   0612
060A:  MOVF   xEF,W
060C:  SUBLW  00
060E:  BTFSC  FD8.0
0610:  BRA    0728
....................                     if (contPasos < pasosmax[nMotor]) { 
0612:  MOVF   xE2,W
0614:  MULLW  04
0616:  MOVF   FF3,W
0618:  CLRF   03
061A:  ADDLW  3B
061C:  MOVWF  FE9
061E:  MOVLW  01
0620:  ADDWFC 03,W
0622:  MOVWF  FEA
0624:  MOVFF  FEF,00
0628:  MOVFF  FEC,01
062C:  MOVFF  FEC,02
0630:  MOVFF  FEC,03
0634:  BTFSC  03.7
0636:  BRA    0726
0638:  MOVF   03,F
063A:  BNZ   064A
063C:  MOVF   02,F
063E:  BNZ   064A
0640:  MOVF   01,F
0642:  BNZ   064A
0644:  MOVF   00,W
0646:  SUBLW  B9
0648:  BC    0726
....................                         contPasos[nMotor] = contPasos[nMotor] + 1; 
064A:  MOVF   xE2,W
064C:  MULLW  04
064E:  MOVF   FF3,W
0650:  CLRF   03
0652:  ADDLW  B9
0654:  MOVWF  01
0656:  MOVLW  00
0658:  ADDWFC 03,F
065A:  MOVFF  01,1EF
065E:  MOVFF  03,1F0
0662:  MOVF   xE2,W
0664:  MULLW  04
0666:  MOVF   FF3,W
0668:  CLRF   03
066A:  ADDLW  B9
066C:  MOVWF  FE9
066E:  MOVLW  00
0670:  ADDWFC 03,W
0672:  MOVWF  FEA
0674:  MOVFF  FEF,1F1
0678:  MOVFF  FEC,1F2
067C:  MOVFF  FEC,1F3
0680:  MOVFF  FEC,1F4
0684:  MOVLW  01
0686:  ADDWF  xF1,W
0688:  MOVWF  00
068A:  MOVLW  00
068C:  ADDWFC xF2,W
068E:  MOVWF  01
0690:  MOVLW  00
0692:  ADDWFC xF3,W
0694:  MOVWF  02
0696:  MOVLW  00
0698:  ADDWFC xF4,W
069A:  MOVFF  1F0,FEA
069E:  MOVFF  1EF,FE9
06A2:  MOVFF  00,FEF
06A6:  MOVFF  01,FEC
06AA:  MOVFF  02,FEC
06AE:  MOVWF  FEC
....................                         if (modoOperacion == 'M' || modoOperacion == 'R' || flagEstirar2 == 1) pasos[nMotor] = pasos[nMotor] - 1; 
06B0:  MOVF   54,W
06B2:  SUBLW  4D
06B4:  BZ    06C0
06B6:  MOVF   54,W
06B8:  SUBLW  52
06BA:  BZ    06C0
06BC:  DECFSZ 5A,W
06BE:  BRA    0726
06C0:  MOVF   xE2,W
06C2:  MULLW  04
06C4:  MOVF   FF3,W
06C6:  CLRF   03
06C8:  ADDLW  95
06CA:  MOVWF  01
06CC:  MOVLW  00
06CE:  ADDWFC 03,F
06D0:  MOVFF  01,1EF
06D4:  MOVFF  03,1F0
06D8:  MOVF   xE2,W
06DA:  MULLW  04
06DC:  MOVF   FF3,W
06DE:  CLRF   03
06E0:  ADDLW  95
06E2:  MOVWF  FE9
06E4:  MOVLW  00
06E6:  ADDWFC 03,W
06E8:  MOVWF  FEA
06EA:  MOVFF  FEF,1F1
06EE:  MOVFF  FEC,1F2
06F2:  MOVFF  FEC,1F3
06F6:  MOVFF  FEC,1F4
06FA:  MOVLW  01
06FC:  SUBWF  xF1,W
06FE:  MOVWF  00
0700:  MOVLW  00
0702:  SUBWFB xF2,W
0704:  MOVWF  01
0706:  MOVLW  00
0708:  SUBWFB xF3,W
070A:  MOVWF  02
070C:  MOVLW  00
070E:  SUBWFB xF4,W
0710:  MOVFF  1F0,FEA
0714:  MOVFF  1EF,FE9
0718:  MOVFF  00,FEF
071C:  MOVFF  01,FEC
0720:  MOVFF  02,FEC
0724:  MOVWF  FEC
....................                     } 
....................                 } else { 
0726:  BRA    0804
....................                     contPasos[nMotor] = contPasos[nMotor] - 1; 
0728:  MOVF   xE2,W
072A:  MULLW  04
072C:  MOVF   FF3,W
072E:  CLRF   03
0730:  ADDLW  B9
0732:  MOVWF  01
0734:  MOVLW  00
0736:  ADDWFC 03,F
0738:  MOVFF  01,1EF
073C:  MOVFF  03,1F0
0740:  MOVF   xE2,W
0742:  MULLW  04
0744:  MOVF   FF3,W
0746:  CLRF   03
0748:  ADDLW  B9
074A:  MOVWF  FE9
074C:  MOVLW  00
074E:  ADDWFC 03,W
0750:  MOVWF  FEA
0752:  MOVFF  FEF,1F1
0756:  MOVFF  FEC,1F2
075A:  MOVFF  FEC,1F3
075E:  MOVFF  FEC,1F4
0762:  MOVLW  01
0764:  SUBWF  xF1,W
0766:  MOVWF  00
0768:  MOVLW  00
076A:  SUBWFB xF2,W
076C:  MOVWF  01
076E:  MOVLW  00
0770:  SUBWFB xF3,W
0772:  MOVWF  02
0774:  MOVLW  00
0776:  SUBWFB xF4,W
0778:  MOVFF  1F0,FEA
077C:  MOVFF  1EF,FE9
0780:  MOVFF  00,FEF
0784:  MOVFF  01,FEC
0788:  MOVFF  02,FEC
078C:  MOVWF  FEC
....................                     if (modoOperacion == 'M' || modoOperacion == 'R' || flagEstirar2 == 1) pasos[nMotor] = pasos[nMotor] + 1; 
078E:  MOVF   54,W
0790:  SUBLW  4D
0792:  BZ    079E
0794:  MOVF   54,W
0796:  SUBLW  52
0798:  BZ    079E
079A:  DECFSZ 5A,W
079C:  BRA    0804
079E:  MOVF   xE2,W
07A0:  MULLW  04
07A2:  MOVF   FF3,W
07A4:  CLRF   03
07A6:  ADDLW  95
07A8:  MOVWF  01
07AA:  MOVLW  00
07AC:  ADDWFC 03,F
07AE:  MOVFF  01,1EF
07B2:  MOVFF  03,1F0
07B6:  MOVF   xE2,W
07B8:  MULLW  04
07BA:  MOVF   FF3,W
07BC:  CLRF   03
07BE:  ADDLW  95
07C0:  MOVWF  FE9
07C2:  MOVLW  00
07C4:  ADDWFC 03,W
07C6:  MOVWF  FEA
07C8:  MOVFF  FEF,1F1
07CC:  MOVFF  FEC,1F2
07D0:  MOVFF  FEC,1F3
07D4:  MOVFF  FEC,1F4
07D8:  MOVLW  01
07DA:  ADDWF  xF1,W
07DC:  MOVWF  00
07DE:  MOVLW  00
07E0:  ADDWFC xF2,W
07E2:  MOVWF  01
07E4:  MOVLW  00
07E6:  ADDWFC xF3,W
07E8:  MOVWF  02
07EA:  MOVLW  00
07EC:  ADDWFC xF4,W
07EE:  MOVFF  1F0,FEA
07F2:  MOVFF  1EF,FE9
07F6:  MOVFF  00,FEF
07FA:  MOVFF  01,FEC
07FE:  MOVFF  02,FEC
0802:  MOVWF  FEC
....................                 } 
....................             } else flagFlanco[nMotor] = 0; 
0804:  BRA    0816
0806:  CLRF   03
0808:  MOVF   xE2,W
080A:  ADDLW  5B
080C:  MOVWF  FE9
080E:  MOVLW  00
0810:  ADDWFC 03,W
0812:  MOVWF  FEA
0814:  CLRF   FEF
....................  
....................         } else if (contPasos[nMotor] == pasosmin[nMotor]) { 
0816:  BRA    0C10
0818:  MOVF   xE2,W
081A:  MULLW  04
081C:  MOVF   FF3,W
081E:  CLRF   03
0820:  ADDLW  B9
0822:  MOVWF  FE9
0824:  MOVLW  00
0826:  ADDWFC 03,W
0828:  MOVWF  FEA
082A:  MOVFF  FEF,1EF
082E:  MOVFF  FEC,1F0
0832:  MOVFF  FEC,1F1
0836:  MOVFF  FEC,1F2
083A:  MOVF   xE2,W
083C:  MULLW  04
083E:  MOVF   FF3,W
0840:  CLRF   03
0842:  ADDLW  53
0844:  MOVWF  FE9
0846:  MOVLW  01
0848:  ADDWFC 03,W
084A:  MOVWF  FEA
084C:  MOVFF  FEF,00
0850:  MOVFF  FEC,01
0854:  MOVFF  FEC,02
0858:  MOVFF  FEC,03
085C:  MOVF   00,W
085E:  SUBWF  xEF,W
0860:  BTFSS  FD8.2
0862:  BRA    0A1C
0864:  MOVF   01,W
0866:  SUBWF  xF0,W
0868:  BTFSS  FD8.2
086A:  BRA    0A1C
086C:  MOVF   02,W
086E:  SUBWF  xF1,W
0870:  BTFSS  FD8.2
0872:  BRA    0A1C
0874:  MOVF   03,W
0876:  SUBWF  xF2,W
0878:  BTFSS  FD8.2
087A:  BRA    0A1C
....................  
....................             if (pasos[nMotor] > 0) { 
087C:  MOVF   xE2,W
087E:  MULLW  04
0880:  MOVF   FF3,W
0882:  CLRF   03
0884:  ADDLW  95
0886:  MOVWF  FE9
0888:  MOVLW  00
088A:  ADDWFC 03,W
088C:  MOVWF  FEA
088E:  MOVFF  FEF,1EF
0892:  MOVFF  FEC,1F0
0896:  MOVFF  FEC,1F1
089A:  MOVFF  FEC,1F2
089E:  BTFSC  xF2.7
08A0:  BRA    0A1A
08A2:  MOVF   xF2,F
08A4:  BNZ   08B6
08A6:  MOVF   xF1,F
08A8:  BNZ   08B6
08AA:  MOVF   xF0,F
08AC:  BNZ   08B6
08AE:  MOVF   xEF,W
08B0:  SUBLW  00
08B2:  BTFSC  FD8.0
08B4:  BRA    0A1A
....................                 output_toggle(STEP_MOTOR[nMotor]); 
08B6:  CLRF   03
08B8:  MOVF   xE2,W
08BA:  ADDLW  E3
08BC:  MOVWF  FE9
08BE:  MOVLW  01
08C0:  ADDWFC 03,W
08C2:  MOVWF  FEA
08C4:  MOVFF  FEF,1EF
08C8:  MOVFF  1EF,1F0
08CC:  MOVLW  0F
08CE:  MOVWF  xF2
08D0:  MOVLW  80
08D2:  MOVWF  xF1
08D4:  MOVLB  0
08D6:  RCALL  02E4
08D8:  MOVLW  00
08DA:  BTFSS  01.0
08DC:  MOVLW  01
08DE:  MOVFF  1EF,1F0
08E2:  MOVLB  1
08E4:  MOVWF  xF1
08E6:  MOVLW  0F
08E8:  MOVWF  xF3
08EA:  MOVLW  89
08EC:  MOVWF  xF2
08EE:  MOVLB  0
08F0:  RCALL  02A2
08F2:  MOVFF  1EF,1F0
08F6:  MOVLB  1
08F8:  CLRF   xF1
08FA:  MOVLW  0F
08FC:  MOVWF  xF3
08FE:  MOVLW  92
0900:  MOVWF  xF2
0902:  MOVLB  0
0904:  RCALL  02A2
....................                 if (flagFlanco[nMotor] == 0) { 
0906:  CLRF   03
0908:  MOVLB  1
090A:  MOVF   xE2,W
090C:  ADDLW  5B
090E:  MOVWF  FE9
0910:  MOVLW  00
0912:  ADDWFC 03,W
0914:  MOVWF  FEA
0916:  MOVF   FEF,F
0918:  BNZ   092E
....................                     flagFlanco[nMotor] = 1; 
091A:  CLRF   03
091C:  MOVF   xE2,W
091E:  ADDLW  5B
0920:  MOVWF  FE9
0922:  MOVLW  00
0924:  ADDWFC 03,W
0926:  MOVWF  FEA
0928:  MOVLW  01
092A:  MOVWF  FEF
....................                 } else { 
092C:  BRA    0A1A
....................                     flagFlanco[nMotor] = 0; 
092E:  CLRF   03
0930:  MOVF   xE2,W
0932:  ADDLW  5B
0934:  MOVWF  FE9
0936:  MOVLW  00
0938:  ADDWFC 03,W
093A:  MOVWF  FEA
093C:  CLRF   FEF
....................                     contPasos[nMotor] = contPasos[nMotor] + 1; 
093E:  MOVF   xE2,W
0940:  MULLW  04
0942:  MOVF   FF3,W
0944:  CLRF   03
0946:  ADDLW  B9
0948:  MOVWF  01
094A:  MOVLW  00
094C:  ADDWFC 03,F
094E:  MOVFF  01,1EF
0952:  MOVFF  03,1F0
0956:  MOVF   xE2,W
0958:  MULLW  04
095A:  MOVF   FF3,W
095C:  CLRF   03
095E:  ADDLW  B9
0960:  MOVWF  FE9
0962:  MOVLW  00
0964:  ADDWFC 03,W
0966:  MOVWF  FEA
0968:  MOVFF  FEF,1F1
096C:  MOVFF  FEC,1F2
0970:  MOVFF  FEC,1F3
0974:  MOVFF  FEC,1F4
0978:  MOVLW  01
097A:  ADDWF  xF1,W
097C:  MOVWF  00
097E:  MOVLW  00
0980:  ADDWFC xF2,W
0982:  MOVWF  01
0984:  MOVLW  00
0986:  ADDWFC xF3,W
0988:  MOVWF  02
098A:  MOVLW  00
098C:  ADDWFC xF4,W
098E:  MOVFF  1F0,FEA
0992:  MOVFF  1EF,FE9
0996:  MOVFF  00,FEF
099A:  MOVFF  01,FEC
099E:  MOVFF  02,FEC
09A2:  MOVWF  FEC
....................                     if (modoOperacion == 'M' || modoOperacion == 'R' || flagEstirar2 == 1) pasos[nMotor] = pasos[nMotor] - 1; 
09A4:  MOVF   54,W
09A6:  SUBLW  4D
09A8:  BZ    09B4
09AA:  MOVF   54,W
09AC:  SUBLW  52
09AE:  BZ    09B4
09B0:  DECFSZ 5A,W
09B2:  BRA    0A1A
09B4:  MOVF   xE2,W
09B6:  MULLW  04
09B8:  MOVF   FF3,W
09BA:  CLRF   03
09BC:  ADDLW  95
09BE:  MOVWF  01
09C0:  MOVLW  00
09C2:  ADDWFC 03,F
09C4:  MOVFF  01,1EF
09C8:  MOVFF  03,1F0
09CC:  MOVF   xE2,W
09CE:  MULLW  04
09D0:  MOVF   FF3,W
09D2:  CLRF   03
09D4:  ADDLW  95
09D6:  MOVWF  FE9
09D8:  MOVLW  00
09DA:  ADDWFC 03,W
09DC:  MOVWF  FEA
09DE:  MOVFF  FEF,1F1
09E2:  MOVFF  FEC,1F2
09E6:  MOVFF  FEC,1F3
09EA:  MOVFF  FEC,1F4
09EE:  MOVLW  01
09F0:  SUBWF  xF1,W
09F2:  MOVWF  00
09F4:  MOVLW  00
09F6:  SUBWFB xF2,W
09F8:  MOVWF  01
09FA:  MOVLW  00
09FC:  SUBWFB xF3,W
09FE:  MOVWF  02
0A00:  MOVLW  00
0A02:  SUBWFB xF4,W
0A04:  MOVFF  1F0,FEA
0A08:  MOVFF  1EF,FE9
0A0C:  MOVFF  00,FEF
0A10:  MOVFF  01,FEC
0A14:  MOVFF  02,FEC
0A18:  MOVWF  FEC
....................                 } 
....................             } 
....................  
....................         } else if (contPasos[nMotor] == pasosmax[nMotor]) { 
0A1A:  BRA    0C10
0A1C:  MOVF   xE2,W
0A1E:  MULLW  04
0A20:  MOVF   FF3,W
0A22:  CLRF   03
0A24:  ADDLW  B9
0A26:  MOVWF  FE9
0A28:  MOVLW  00
0A2A:  ADDWFC 03,W
0A2C:  MOVWF  FEA
0A2E:  MOVFF  FEF,1EF
0A32:  MOVFF  FEC,1F0
0A36:  MOVFF  FEC,1F1
0A3A:  MOVFF  FEC,1F2
0A3E:  MOVF   xE2,W
0A40:  MULLW  04
0A42:  MOVF   FF3,W
0A44:  CLRF   03
0A46:  ADDLW  3B
0A48:  MOVWF  FE9
0A4A:  MOVLW  01
0A4C:  ADDWFC 03,W
0A4E:  MOVWF  FEA
0A50:  MOVFF  FEF,00
0A54:  MOVFF  FEC,01
0A58:  MOVFF  FEC,02
0A5C:  MOVFF  FEC,03
0A60:  MOVF   00,W
0A62:  SUBWF  xEF,W
0A64:  BTFSS  FD8.2
0A66:  BRA    0C10
0A68:  MOVF   01,W
0A6A:  SUBWF  xF0,W
0A6C:  BTFSS  FD8.2
0A6E:  BRA    0C10
0A70:  MOVF   02,W
0A72:  SUBWF  xF1,W
0A74:  BTFSS  FD8.2
0A76:  BRA    0C10
0A78:  MOVF   03,W
0A7A:  SUBWF  xF2,W
0A7C:  BTFSS  FD8.2
0A7E:  BRA    0C10
....................             if (pasos[nMotor] < 0) { 
0A80:  MOVF   xE2,W
0A82:  MULLW  04
0A84:  MOVF   FF3,W
0A86:  CLRF   03
0A88:  ADDLW  95
0A8A:  MOVWF  FE9
0A8C:  MOVLW  00
0A8E:  ADDWFC 03,W
0A90:  MOVWF  FEA
0A92:  MOVFF  FEF,1EF
0A96:  MOVFF  FEC,1F0
0A9A:  MOVFF  FEC,1F1
0A9E:  MOVFF  FEC,1F2
0AA2:  BTFSC  xF2.7
0AA4:  BRA    0AA8
0AA6:  BRA    0C10
....................                 output_toggle(STEP_MOTOR[nMotor]); 
0AA8:  CLRF   03
0AAA:  MOVF   xE2,W
0AAC:  ADDLW  E3
0AAE:  MOVWF  FE9
0AB0:  MOVLW  01
0AB2:  ADDWFC 03,W
0AB4:  MOVWF  FEA
0AB6:  MOVFF  FEF,1EF
0ABA:  MOVFF  1EF,1F0
0ABE:  MOVLW  0F
0AC0:  MOVWF  xF2
0AC2:  MOVLW  80
0AC4:  MOVWF  xF1
0AC6:  MOVLB  0
0AC8:  RCALL  02E4
0ACA:  MOVLW  00
0ACC:  BTFSS  01.0
0ACE:  MOVLW  01
0AD0:  MOVFF  1EF,1F0
0AD4:  MOVLB  1
0AD6:  MOVWF  xF1
0AD8:  MOVLW  0F
0ADA:  MOVWF  xF3
0ADC:  MOVLW  89
0ADE:  MOVWF  xF2
0AE0:  MOVLB  0
0AE2:  CALL   02A2
0AE6:  MOVFF  1EF,1F0
0AEA:  MOVLB  1
0AEC:  CLRF   xF1
0AEE:  MOVLW  0F
0AF0:  MOVWF  xF3
0AF2:  MOVLW  92
0AF4:  MOVWF  xF2
0AF6:  MOVLB  0
0AF8:  CALL   02A2
....................                 if (flagFlanco[nMotor] == 0) { 
0AFC:  CLRF   03
0AFE:  MOVLB  1
0B00:  MOVF   xE2,W
0B02:  ADDLW  5B
0B04:  MOVWF  FE9
0B06:  MOVLW  00
0B08:  ADDWFC 03,W
0B0A:  MOVWF  FEA
0B0C:  MOVF   FEF,F
0B0E:  BNZ   0B24
....................                     flagFlanco[nMotor] = 1; 
0B10:  CLRF   03
0B12:  MOVF   xE2,W
0B14:  ADDLW  5B
0B16:  MOVWF  FE9
0B18:  MOVLW  00
0B1A:  ADDWFC 03,W
0B1C:  MOVWF  FEA
0B1E:  MOVLW  01
0B20:  MOVWF  FEF
....................                 } else { 
0B22:  BRA    0C10
....................                     flagFlanco[nMotor] = 0; 
0B24:  CLRF   03
0B26:  MOVF   xE2,W
0B28:  ADDLW  5B
0B2A:  MOVWF  FE9
0B2C:  MOVLW  00
0B2E:  ADDWFC 03,W
0B30:  MOVWF  FEA
0B32:  CLRF   FEF
....................                     contPasos[nMotor] = contPasos[nMotor] - 1; 
0B34:  MOVF   xE2,W
0B36:  MULLW  04
0B38:  MOVF   FF3,W
0B3A:  CLRF   03
0B3C:  ADDLW  B9
0B3E:  MOVWF  01
0B40:  MOVLW  00
0B42:  ADDWFC 03,F
0B44:  MOVFF  01,1EF
0B48:  MOVFF  03,1F0
0B4C:  MOVF   xE2,W
0B4E:  MULLW  04
0B50:  MOVF   FF3,W
0B52:  CLRF   03
0B54:  ADDLW  B9
0B56:  MOVWF  FE9
0B58:  MOVLW  00
0B5A:  ADDWFC 03,W
0B5C:  MOVWF  FEA
0B5E:  MOVFF  FEF,1F1
0B62:  MOVFF  FEC,1F2
0B66:  MOVFF  FEC,1F3
0B6A:  MOVFF  FEC,1F4
0B6E:  MOVLW  01
0B70:  SUBWF  xF1,W
0B72:  MOVWF  00
0B74:  MOVLW  00
0B76:  SUBWFB xF2,W
0B78:  MOVWF  01
0B7A:  MOVLW  00
0B7C:  SUBWFB xF3,W
0B7E:  MOVWF  02
0B80:  MOVLW  00
0B82:  SUBWFB xF4,W
0B84:  MOVFF  1F0,FEA
0B88:  MOVFF  1EF,FE9
0B8C:  MOVFF  00,FEF
0B90:  MOVFF  01,FEC
0B94:  MOVFF  02,FEC
0B98:  MOVWF  FEC
....................                     if (modoOperacion == 'M' || modoOperacion == 'R' || flagEstirar2 == 1) pasos[nMotor] = pasos[nMotor] + 1; 
0B9A:  MOVF   54,W
0B9C:  SUBLW  4D
0B9E:  BZ    0BAA
0BA0:  MOVF   54,W
0BA2:  SUBLW  52
0BA4:  BZ    0BAA
0BA6:  DECFSZ 5A,W
0BA8:  BRA    0C10
0BAA:  MOVF   xE2,W
0BAC:  MULLW  04
0BAE:  MOVF   FF3,W
0BB0:  CLRF   03
0BB2:  ADDLW  95
0BB4:  MOVWF  01
0BB6:  MOVLW  00
0BB8:  ADDWFC 03,F
0BBA:  MOVFF  01,1EF
0BBE:  MOVFF  03,1F0
0BC2:  MOVF   xE2,W
0BC4:  MULLW  04
0BC6:  MOVF   FF3,W
0BC8:  CLRF   03
0BCA:  ADDLW  95
0BCC:  MOVWF  FE9
0BCE:  MOVLW  00
0BD0:  ADDWFC 03,W
0BD2:  MOVWF  FEA
0BD4:  MOVFF  FEF,1F1
0BD8:  MOVFF  FEC,1F2
0BDC:  MOVFF  FEC,1F3
0BE0:  MOVFF  FEC,1F4
0BE4:  MOVLW  01
0BE6:  ADDWF  xF1,W
0BE8:  MOVWF  00
0BEA:  MOVLW  00
0BEC:  ADDWFC xF2,W
0BEE:  MOVWF  01
0BF0:  MOVLW  00
0BF2:  ADDWFC xF3,W
0BF4:  MOVWF  02
0BF6:  MOVLW  00
0BF8:  ADDWFC xF4,W
0BFA:  MOVFF  1F0,FEA
0BFE:  MOVFF  1EF,FE9
0C02:  MOVFF  00,FEF
0C06:  MOVFF  01,FEC
0C0A:  MOVFF  02,FEC
0C0E:  MOVWF  FEC
....................                 } 
....................             } 
....................         } 
....................  
....................         velocidad[nMotor] = velofija[nMotor]; 
0C10:  CLRF   03
0C12:  MOVF   xE2,W
0C14:  ADDLW  AD
0C16:  MOVWF  01
0C18:  MOVLW  00
0C1A:  ADDWFC 03,F
0C1C:  MOVFF  03,1F0
0C20:  CLRF   03
0C22:  MOVF   xE2,W
0C24:  ADDLW  B3
0C26:  MOVWF  FE9
0C28:  MOVLW  00
0C2A:  ADDWFC 03,W
0C2C:  MOVWF  FEA
0C2E:  MOVFF  FEF,1F1
0C32:  MOVFF  1F0,FEA
0C36:  MOVFF  01,FE9
0C3A:  MOVFF  1F1,FEF
....................  
....................     } else if (pasos[nMotor] == 0) output_low(STEP_MOTOR[nMotor]); 
0C3E:  BRA    0CB0
0C40:  MOVF   xE2,W
0C42:  MULLW  04
0C44:  MOVF   FF3,W
0C46:  CLRF   03
0C48:  ADDLW  95
0C4A:  MOVWF  FE9
0C4C:  MOVLW  00
0C4E:  ADDWFC 03,W
0C50:  MOVWF  FEA
0C52:  MOVFF  FEF,1EF
0C56:  MOVFF  FEC,1F0
0C5A:  MOVFF  FEC,1F1
0C5E:  MOVFF  FEC,1F2
0C62:  MOVF   xEF,F
0C64:  BNZ   0CB0
0C66:  MOVF   xF0,F
0C68:  BNZ   0CB0
0C6A:  MOVF   xF1,F
0C6C:  BNZ   0CB0
0C6E:  MOVF   xF2,F
0C70:  BNZ   0CB0
0C72:  CLRF   03
0C74:  MOVF   xE2,W
0C76:  ADDLW  E3
0C78:  MOVWF  FE9
0C7A:  MOVLW  01
0C7C:  ADDWFC 03,W
0C7E:  MOVWF  FEA
0C80:  MOVFF  FEF,1EF
0C84:  MOVFF  1EF,1F0
0C88:  CLRF   xF1
0C8A:  MOVLW  0F
0C8C:  MOVWF  xF3
0C8E:  MOVLW  89
0C90:  MOVWF  xF2
0C92:  MOVLB  0
0C94:  CALL   02A2
0C98:  MOVFF  1EF,1F0
0C9C:  MOVLB  1
0C9E:  CLRF   xF1
0CA0:  MOVLW  0F
0CA2:  MOVWF  xF3
0CA4:  MOVLW  92
0CA6:  MOVWF  xF2
0CA8:  MOVLB  0
0CAA:  CALL   02A2
0CAE:  MOVLB  1
0CB0:  MOVLB  0
0CB2:  RETURN 0
....................  
....................  
.................... } 
....................  
.................... void estirar(void) { 
....................  
....................     int8 nMotor; 
....................  
....................     for (nMotor = 0; nMotor < 6; nMotor++) { 
*
1E48:  MOVLB  1
1E4A:  CLRF   x7D
1E4C:  MOVF   x7D,W
1E4E:  SUBLW  05
1E50:  BTFSS  FD8.0
1E52:  BRA    1F44
....................  
....................         pasos[nMotor] = pasosEstirado[nMotor] - contPasos[nMotor]; 
1E54:  MOVF   x7D,W
1E56:  MULLW  04
1E58:  MOVF   FF3,W
1E5A:  CLRF   03
1E5C:  ADDLW  95
1E5E:  MOVWF  01
1E60:  MOVLW  00
1E62:  ADDWFC 03,F
1E64:  MOVFF  01,17E
1E68:  MOVFF  03,17F
1E6C:  BCF    FD8.0
1E6E:  RLCF   x7D,W
1E70:  CLRF   03
1E72:  ADDLW  71
1E74:  MOVWF  FE9
1E76:  MOVLW  01
1E78:  ADDWFC 03,W
1E7A:  MOVWF  FEA
1E7C:  MOVFF  FEC,181
1E80:  MOVF   FED,F
1E82:  MOVFF  FEF,180
1E86:  MOVF   x7D,W
1E88:  MULLW  04
1E8A:  MOVF   FF3,W
1E8C:  CLRF   03
1E8E:  ADDLW  B9
1E90:  MOVWF  FE9
1E92:  MOVLW  00
1E94:  ADDWFC 03,W
1E96:  MOVWF  FEA
1E98:  MOVFF  FEF,00
1E9C:  MOVFF  FEC,01
1EA0:  MOVFF  FEC,02
1EA4:  MOVFF  FEC,03
1EA8:  MOVF   00,W
1EAA:  SUBWF  x80,W
1EAC:  MOVWF  00
1EAE:  MOVF   01,W
1EB0:  SUBWFB x81,W
1EB2:  MOVWF  01
1EB4:  MOVLW  00
1EB6:  SUBFWB 02,F
1EB8:  SUBFWB 03,F
1EBA:  MOVFF  17F,FEA
1EBE:  MOVFF  17E,FE9
1EC2:  MOVFF  00,FEF
1EC6:  MOVFF  01,FEC
1ECA:  MOVFF  02,FEC
1ECE:  MOVFF  03,FEC
....................  
....................         switch (nMotor) { 
1ED2:  MOVF   x7D,W
1ED4:  ADDLW  FA
1ED6:  BC    1F12
1ED8:  ADDLW  06
1EDA:  MOVLB  0
1EDC:  GOTO   1F60
....................  
....................             case 0: 
....................                 velocidad[0] = 5; 
1EE0:  MOVLW  05
1EE2:  MOVWF  xAD
....................                 break; 
1EE4:  MOVLB  1
1EE6:  BRA    1F12
....................  
....................             case 1: 
....................                 velocidad[1] = 12; 
1EE8:  MOVLW  0C
1EEA:  MOVWF  xAE
....................                 //velocidad[1] = 3; 
....................                 break; 
1EEC:  MOVLB  1
1EEE:  BRA    1F12
....................  
....................             case 2: 
....................                 velocidad[2] = 1; 
1EF0:  MOVLW  01
1EF2:  MOVWF  xAF
....................                 break; 
1EF4:  MOVLB  1
1EF6:  BRA    1F12
....................  
....................             case 3: 
....................                 velocidad[3] = 50; 
1EF8:  MOVLW  32
1EFA:  MOVWF  xB0
....................                 break; 
1EFC:  MOVLB  1
1EFE:  BRA    1F12
....................  
....................             case 4: 
....................                 velocidad[4] = 5; 
1F00:  MOVLW  05
1F02:  MOVWF  xB1
....................                 break; 
1F04:  MOVLB  1
1F06:  BRA    1F12
....................  
....................             case 5: 
....................                 velocidad[5] = 5; 
1F08:  MOVLW  05
1F0A:  MOVWF  xB2
....................                 break; 
1F0C:  MOVLB  1
1F0E:  BRA    1F12
1F10:  MOVLB  1
....................  
....................         } 
....................  
....................         velofija[nMotor] = velocidad[nMotor]; 
1F12:  CLRF   03
1F14:  MOVF   x7D,W
1F16:  ADDLW  B3
1F18:  MOVWF  01
1F1A:  MOVLW  00
1F1C:  ADDWFC 03,F
1F1E:  MOVFF  03,17F
1F22:  CLRF   03
1F24:  MOVF   x7D,W
1F26:  ADDLW  AD
1F28:  MOVWF  FE9
1F2A:  MOVLW  00
1F2C:  ADDWFC 03,W
1F2E:  MOVWF  FEA
1F30:  MOVFF  FEF,180
1F34:  MOVFF  17F,FEA
1F38:  MOVFF  01,FE9
1F3C:  MOVFF  180,FEF
1F40:  INCF   x7D,F
1F42:  BRA    1E4C
....................  
....................     } 
....................      
....................     flagEstirar2 = 1; 
1F44:  MOVLW  01
1F46:  MOVWF  5A
....................     flagTimer = 1; 
1F48:  MOVLB  0
1F4A:  MOVWF  x61
1F4C:  CLRF   16
1F4E:  BTFSC  FF2.7
1F50:  BSF    16.7
1F52:  BCF    FF2.7
....................     inicbuff(); 
1F54:  CALL   0CB4
1F58:  BTFSC  16.7
1F5A:  BSF    FF2.7
1F5C:  GOTO   2E3A (RETURN)
....................  
.................... } 
....................  
.................... void inicbuff(void) { 
....................  
....................     for (int i = 0; i < lenbuff; i++) { // Bucle que pone a 0 todos los 
*
0CB4:  MOVLB  1
0CB6:  CLRF   xE2
0CB8:  MOVF   xE2,W
0CBA:  SUBLW  31
0CBC:  BNC   0CD2
....................         cbuff[ i ] = 0x00; // caracteres en el buffer 
0CBE:  CLRF   03
0CC0:  MOVF   xE2,W
0CC2:  ADDLW  1F
0CC4:  MOVWF  FE9
0CC6:  MOVLW  00
0CC8:  ADDWFC 03,W
0CCA:  MOVWF  FEA
0CCC:  CLRF   FEF
0CCE:  INCF   xE2,F
0CD0:  BRA    0CB8
....................     } 
....................     xbuff = 0x00; // Inicializo el indice de siguiente caracter 
0CD2:  CLRF   1E
0CD4:  MOVLB  0
0CD6:  RETURN 0
....................  
.................... } 
....................  
.................... void crearSecInit(void) { 
....................      
....................     for (int i = 0; i < 6; i++) { 
*
29AC:  MOVLB  1
29AE:  CLRF   x7D
29B0:  MOVF   x7D,W
29B2:  SUBLW  05
29B4:  BNC   2A6C
....................          
....................         pasosAnteriores[i] = pasosEstirado[i]; 
29B6:  MOVF   x7D,W
29B8:  MULLW  04
29BA:  MOVF   FF3,W
29BC:  CLRF   03
29BE:  ADDLW  D1
29C0:  MOVWF  01
29C2:  MOVLW  00
29C4:  ADDWFC 03,F
29C6:  MOVFF  01,17E
29CA:  MOVFF  03,17F
29CE:  BCF    FD8.0
29D0:  RLCF   x7D,W
29D2:  CLRF   03
29D4:  ADDLW  71
29D6:  MOVWF  FE9
29D8:  MOVLW  01
29DA:  ADDWFC 03,W
29DC:  MOVWF  FEA
29DE:  MOVFF  FEC,03
29E2:  MOVF   FED,F
29E4:  MOVFF  FEF,00
29E8:  MOVFF  03,01
29EC:  CLRF   02
29EE:  CLRF   03
29F0:  MOVFF  17F,FEA
29F4:  MOVFF  17E,FE9
29F8:  MOVFF  00,FEF
29FC:  MOVFF  01,FEC
2A00:  MOVFF  02,FEC
2A04:  MOVFF  03,FEC
....................         pasosActuales[i] = 0; 
2A08:  MOVF   x7D,W
2A0A:  MULLW  04
2A0C:  MOVF   FF3,W
2A0E:  CLRF   03
2A10:  ADDLW  E9
2A12:  MOVWF  FE9
2A14:  MOVLW  00
2A16:  ADDWFC 03,W
2A18:  MOVWF  FEA
2A1A:  CLRF   FEF
2A1C:  CLRF   FEC
2A1E:  CLRF   FEC
2A20:  CLRF   FEC
....................         pasosDados[i] = 0; 
2A22:  MOVF   x7D,W
2A24:  MULLW  04
2A26:  MOVF   FF3,W
2A28:  CLRF   03
2A2A:  ADDLW  01
2A2C:  MOVWF  FE9
2A2E:  MOVLW  01
2A30:  ADDWFC 03,W
2A32:  MOVWF  FEA
2A34:  CLRF   FEF
2A36:  CLRF   FEC
2A38:  CLRF   FEC
2A3A:  CLRF   FEC
....................         arrayPasos[i] = 0; 
2A3C:  MOVF   x7D,W
2A3E:  MULLW  04
2A40:  MOVF   FF3,W
2A42:  CLRF   03
2A44:  ADDLW  19
2A46:  MOVWF  FE9
2A48:  MOVLW  01
2A4A:  ADDWFC 03,W
2A4C:  MOVWF  FEA
2A4E:  CLRF   FEF
2A50:  CLRF   FEC
2A52:  CLRF   FEC
2A54:  CLRF   FEC
....................         signoPasos[i] = '+'; 
2A56:  CLRF   03
2A58:  MOVF   x7D,W
2A5A:  ADDLW  6B
2A5C:  MOVWF  FE9
2A5E:  MOVLW  01
2A60:  ADDWFC 03,W
2A62:  MOVWF  FEA
2A64:  MOVLW  2B
2A66:  MOVWF  FEF
2A68:  INCF   x7D,F
2A6A:  BRA    29B0
....................          
....................     } 
2A6C:  MOVLB  0
2A6E:  GOTO   2E50 (RETURN)
....................      
.................... } 
....................  
.................... void calcularPasosDados(void) { 
....................      
....................     for (int i = 0; i < 6; i++) { 
2A72:  MOVLB  1
2A74:  CLRF   x7D
2A76:  MOVF   x7D,W
2A78:  SUBLW  05
2A7A:  BTFSS  FD8.0
2A7C:  BRA    2CCC
....................          
....................         pasosActuales[i] = contPasos[i]; 
2A7E:  MOVF   x7D,W
2A80:  MULLW  04
2A82:  MOVF   FF3,W
2A84:  CLRF   03
2A86:  ADDLW  E9
2A88:  MOVWF  01
2A8A:  MOVLW  00
2A8C:  ADDWFC 03,F
2A8E:  MOVFF  01,17E
2A92:  MOVFF  03,17F
2A96:  MOVF   x7D,W
2A98:  MULLW  04
2A9A:  MOVF   FF3,W
2A9C:  CLRF   03
2A9E:  ADDLW  B9
2AA0:  MOVWF  FE9
2AA2:  MOVLW  00
2AA4:  ADDWFC 03,W
2AA6:  MOVWF  FEA
2AA8:  MOVFF  FEF,00
2AAC:  MOVFF  FEC,01
2AB0:  MOVFF  FEC,02
2AB4:  MOVFF  FEC,03
2AB8:  MOVFF  17F,FEA
2ABC:  MOVFF  17E,FE9
2AC0:  MOVFF  00,FEF
2AC4:  MOVFF  01,FEC
2AC8:  MOVFF  02,FEC
2ACC:  MOVFF  03,FEC
....................          
....................         if (pasosActuales[i] >= pasosAnteriores[i]) { 
2AD0:  MOVF   x7D,W
2AD2:  MULLW  04
2AD4:  MOVF   FF3,W
2AD6:  CLRF   03
2AD8:  ADDLW  E9
2ADA:  MOVWF  FE9
2ADC:  MOVLW  00
2ADE:  ADDWFC 03,W
2AE0:  MOVWF  FEA
2AE2:  MOVFF  FEF,17E
2AE6:  MOVFF  FEC,17F
2AEA:  MOVFF  FEC,180
2AEE:  MOVFF  FEC,181
2AF2:  MOVF   x7D,W
2AF4:  MULLW  04
2AF6:  MOVF   FF3,W
2AF8:  CLRF   03
2AFA:  ADDLW  D1
2AFC:  MOVWF  FE9
2AFE:  MOVLW  00
2B00:  ADDWFC 03,W
2B02:  MOVWF  FEA
2B04:  MOVFF  FEF,00
2B08:  MOVFF  FEC,01
2B0C:  MOVFF  FEC,02
2B10:  MOVFF  FEC,03
2B14:  BTFSS  03.7
2B16:  BRA    2B1E
2B18:  BTFSS  x81.7
2B1A:  BRA    2B40
2B1C:  BRA    2B22
2B1E:  BTFSC  x81.7
2B20:  BRA    2BDC
2B22:  MOVF   03,W
2B24:  SUBWF  x81,W
2B26:  BNC   2BDC
2B28:  BNZ   2B40
2B2A:  MOVF   02,W
2B2C:  SUBWF  x80,W
2B2E:  BNC   2BDC
2B30:  BNZ   2B40
2B32:  MOVF   01,W
2B34:  SUBWF  x7F,W
2B36:  BNC   2BDC
2B38:  BNZ   2B40
2B3A:  MOVF   00,W
2B3C:  SUBWF  x7E,W
2B3E:  BNC   2BDC
....................             //Mov Positivo 
....................             pasosDados[i] = pasosActuales[i] - pasosAnteriores[i]; 
2B40:  MOVF   x7D,W
2B42:  MULLW  04
2B44:  MOVF   FF3,W
2B46:  CLRF   03
2B48:  ADDLW  01
2B4A:  MOVWF  01
2B4C:  MOVLW  01
2B4E:  ADDWFC 03,F
2B50:  MOVFF  01,17E
2B54:  MOVFF  03,17F
2B58:  MOVF   x7D,W
2B5A:  MULLW  04
2B5C:  MOVF   FF3,W
2B5E:  CLRF   03
2B60:  ADDLW  E9
2B62:  MOVWF  FE9
2B64:  MOVLW  00
2B66:  ADDWFC 03,W
2B68:  MOVWF  FEA
2B6A:  MOVFF  FEF,180
2B6E:  MOVFF  FEC,181
2B72:  MOVFF  FEC,182
2B76:  MOVFF  FEC,183
2B7A:  MOVF   x7D,W
2B7C:  MULLW  04
2B7E:  MOVF   FF3,W
2B80:  CLRF   03
2B82:  ADDLW  D1
2B84:  MOVWF  FE9
2B86:  MOVLW  00
2B88:  ADDWFC 03,W
2B8A:  MOVWF  FEA
2B8C:  MOVFF  FEF,00
2B90:  MOVFF  FEC,01
2B94:  MOVFF  FEC,02
2B98:  MOVFF  FEC,03
2B9C:  MOVF   00,W
2B9E:  SUBWF  x80,W
2BA0:  MOVWF  00
2BA2:  MOVF   01,W
2BA4:  SUBWFB x81,W
2BA6:  MOVWF  01
2BA8:  MOVF   02,W
2BAA:  SUBWFB x82,W
2BAC:  MOVWF  02
2BAE:  MOVF   03,W
2BB0:  SUBWFB x83,W
2BB2:  MOVFF  17F,FEA
2BB6:  MOVFF  17E,FE9
2BBA:  MOVFF  00,FEF
2BBE:  MOVFF  01,FEC
2BC2:  MOVFF  02,FEC
2BC6:  MOVWF  FEC
....................             signoPasos[i] = '+'; 
2BC8:  CLRF   03
2BCA:  MOVF   x7D,W
2BCC:  ADDLW  6B
2BCE:  MOVWF  FE9
2BD0:  MOVLW  01
2BD2:  ADDWFC 03,W
2BD4:  MOVWF  FEA
2BD6:  MOVLW  2B
2BD8:  MOVWF  FEF
....................         } else { 
2BDA:  BRA    2C76
....................             //Mov Negativo 
....................             pasosDados[i] = pasosAnteriores[i] - pasosActuales[i]; 
2BDC:  MOVF   x7D,W
2BDE:  MULLW  04
2BE0:  MOVF   FF3,W
2BE2:  CLRF   03
2BE4:  ADDLW  01
2BE6:  MOVWF  01
2BE8:  MOVLW  01
2BEA:  ADDWFC 03,F
2BEC:  MOVFF  01,17E
2BF0:  MOVFF  03,17F
2BF4:  MOVF   x7D,W
2BF6:  MULLW  04
2BF8:  MOVF   FF3,W
2BFA:  CLRF   03
2BFC:  ADDLW  D1
2BFE:  MOVWF  FE9
2C00:  MOVLW  00
2C02:  ADDWFC 03,W
2C04:  MOVWF  FEA
2C06:  MOVFF  FEF,180
2C0A:  MOVFF  FEC,181
2C0E:  MOVFF  FEC,182
2C12:  MOVFF  FEC,183
2C16:  MOVF   x7D,W
2C18:  MULLW  04
2C1A:  MOVF   FF3,W
2C1C:  CLRF   03
2C1E:  ADDLW  E9
2C20:  MOVWF  FE9
2C22:  MOVLW  00
2C24:  ADDWFC 03,W
2C26:  MOVWF  FEA
2C28:  MOVFF  FEF,00
2C2C:  MOVFF  FEC,01
2C30:  MOVFF  FEC,02
2C34:  MOVFF  FEC,03
2C38:  MOVF   00,W
2C3A:  SUBWF  x80,W
2C3C:  MOVWF  00
2C3E:  MOVF   01,W
2C40:  SUBWFB x81,W
2C42:  MOVWF  01
2C44:  MOVF   02,W
2C46:  SUBWFB x82,W
2C48:  MOVWF  02
2C4A:  MOVF   03,W
2C4C:  SUBWFB x83,W
2C4E:  MOVFF  17F,FEA
2C52:  MOVFF  17E,FE9
2C56:  MOVFF  00,FEF
2C5A:  MOVFF  01,FEC
2C5E:  MOVFF  02,FEC
2C62:  MOVWF  FEC
....................             signoPasos[i] = '-'; 
2C64:  CLRF   03
2C66:  MOVF   x7D,W
2C68:  ADDLW  6B
2C6A:  MOVWF  FE9
2C6C:  MOVLW  01
2C6E:  ADDWFC 03,W
2C70:  MOVWF  FEA
2C72:  MOVLW  2D
2C74:  MOVWF  FEF
....................         } 
....................          
....................         pasosAnteriores[i] = pasosActuales[i]; 
2C76:  MOVF   x7D,W
2C78:  MULLW  04
2C7A:  MOVF   FF3,W
2C7C:  CLRF   03
2C7E:  ADDLW  D1
2C80:  MOVWF  01
2C82:  MOVLW  00
2C84:  ADDWFC 03,F
2C86:  MOVFF  01,17E
2C8A:  MOVFF  03,17F
2C8E:  MOVF   x7D,W
2C90:  MULLW  04
2C92:  MOVF   FF3,W
2C94:  CLRF   03
2C96:  ADDLW  E9
2C98:  MOVWF  FE9
2C9A:  MOVLW  00
2C9C:  ADDWFC 03,W
2C9E:  MOVWF  FEA
2CA0:  MOVFF  FEF,00
2CA4:  MOVFF  FEC,01
2CA8:  MOVFF  FEC,02
2CAC:  MOVFF  FEC,03
2CB0:  MOVFF  17F,FEA
2CB4:  MOVFF  17E,FE9
2CB8:  MOVFF  00,FEF
2CBC:  MOVFF  01,FEC
2CC0:  MOVFF  02,FEC
2CC4:  MOVFF  03,FEC
2CC8:  INCF   x7D,F
2CCA:  BRA    2A76
....................          
....................     } 
....................      
....................     flagArmarPaquete = 1; 
2CCC:  MOVLW  01
2CCE:  MOVLB  0
2CD0:  MOVWF  x65
....................     flagPaquetePasosDados = 1; 
2CD2:  MOVWF  x68
2CD4:  GOTO   2E58 (RETURN)
....................  
.................... } 
....................  
.................... void procesa_comando(void) { 
*
2728:  MOVLB  1
272A:  CLRF   x7E
272C:  CLRF   x7F
272E:  CLRF   x80
....................  
....................     int i; 
....................     int h = 0; 
....................     int k = 0; 
....................     int w = 0; 
....................  
....................     for (w = 0; w < cantPaquetes; w++) { 
2730:  CLRF   x80
2732:  MOVF   53,W
2734:  SUBWF  x80,W
2736:  BC    27B4
....................  
....................         i = cbuff[h]; 
2738:  CLRF   03
273A:  MOVF   x7E,W
273C:  ADDLW  1F
273E:  MOVWF  FE9
2740:  MOVLW  00
2742:  ADDWFC 03,W
2744:  MOVWF  FEA
2746:  MOVFF  FEF,17D
....................         j = i - 49; //Transforma de ASCII a decimal y resta 1 para referise a la posicion del vector 
274A:  MOVLW  31
274C:  SUBWF  x7D,W
274E:  MOVLB  0
2750:  MOVWF  x94
....................  
....................         for (k = 0; k < 7; k++) { // 7 es la longitud del PAQUETE 
2752:  MOVLB  1
2754:  CLRF   x7F
2756:  MOVF   x7F,W
2758:  SUBLW  06
275A:  BNC   27AC
....................             motor[j][k] = cbuff[h + 1]; 
275C:  MOVLB  0
275E:  MOVF   x94,W
2760:  MULLW  07
2762:  MOVF   FF3,W
2764:  MOVLB  1
2766:  CLRF   x82
2768:  MOVWF  x81
276A:  CLRF   03
276C:  MOVF   x7F,W
276E:  ADDWF  x81,W
2770:  MOVWF  01
2772:  MOVF   x82,W
2774:  ADDWFC 03,F
2776:  MOVF   01,W
2778:  ADDLW  69
277A:  MOVWF  01
277C:  MOVLW  00
277E:  ADDWFC 03,F
2780:  MOVFF  03,182
2784:  MOVLW  01
2786:  ADDWF  x7E,W
2788:  CLRF   03
278A:  ADDLW  1F
278C:  MOVWF  FE9
278E:  MOVLW  00
2790:  ADDWFC 03,W
2792:  MOVWF  FEA
2794:  MOVFF  FEF,183
2798:  MOVFF  182,FEA
279C:  MOVFF  01,FE9
27A0:  MOVFF  183,FEF
....................             h = h + 1; 
27A4:  MOVLW  01
27A6:  ADDWF  x7E,F
27A8:  INCF   x7F,F
27AA:  BRA    2756
....................         } 
....................  
....................         h = h + 1; 
27AC:  MOVLW  01
27AE:  ADDWF  x7E,F
27B0:  INCF   x80,F
27B2:  BRA    2732
....................  
....................     } 
....................  
....................     for (i = 0; i < 6; i++) { 
27B4:  CLRF   x7D
27B6:  MOVF   x7D,W
27B8:  SUBLW  05
27BA:  BTFSS  FD8.0
27BC:  BRA    2986
....................  
....................         provi[0] = motor[i][0]; 
27BE:  MOVF   x7D,W
27C0:  MULLW  07
27C2:  MOVF   FF3,W
27C4:  CLRF   x82
27C6:  MOVWF  x81
27C8:  MOVLW  69
27CA:  ADDWF  x81,W
27CC:  MOVWF  FE9
27CE:  MOVLW  00
27D0:  ADDWFC x82,W
27D2:  MOVWF  FEA
27D4:  MOVFF  FEF,131
....................         provi[1] = motor[i][1]; 
27D8:  MOVF   x7D,W
27DA:  MULLW  07
27DC:  MOVF   FF3,W
27DE:  CLRF   x82
27E0:  MOVWF  x81
27E2:  MOVLW  01
27E4:  ADDWF  x81,W
27E6:  MOVWF  01
27E8:  MOVLW  00
27EA:  ADDWFC x82,W
27EC:  MOVWF  03
27EE:  MOVF   01,W
27F0:  ADDLW  69
27F2:  MOVWF  FE9
27F4:  MOVLW  00
27F6:  ADDWFC 03,W
27F8:  MOVWF  FEA
27FA:  MOVFF  FEF,132
....................         provi[2] = motor[i][2]; 
27FE:  MOVF   x7D,W
2800:  MULLW  07
2802:  MOVF   FF3,W
2804:  CLRF   x82
2806:  MOVWF  x81
2808:  MOVLW  02
280A:  ADDWF  x81,W
280C:  MOVWF  01
280E:  MOVLW  00
2810:  ADDWFC x82,W
2812:  MOVWF  03
2814:  MOVF   01,W
2816:  ADDLW  69
2818:  MOVWF  FE9
281A:  MOVLW  00
281C:  ADDWFC 03,W
281E:  MOVWF  FEA
2820:  MOVFF  FEF,133
....................         provi[3] = motor[i][3]; 
2824:  MOVF   x7D,W
2826:  MULLW  07
2828:  MOVF   FF3,W
282A:  CLRF   x82
282C:  MOVWF  x81
282E:  MOVLW  03
2830:  ADDWF  x81,W
2832:  MOVWF  01
2834:  MOVLW  00
2836:  ADDWFC x82,W
2838:  MOVWF  03
283A:  MOVF   01,W
283C:  ADDLW  69
283E:  MOVWF  FE9
2840:  MOVLW  00
2842:  ADDWFC 03,W
2844:  MOVWF  FEA
2846:  MOVFF  FEF,134
....................         provi[4] = motor[i][4]; 
284A:  MOVF   x7D,W
284C:  MULLW  07
284E:  MOVF   FF3,W
2850:  CLRF   x82
2852:  MOVWF  x81
2854:  MOVLW  04
2856:  ADDWF  x81,W
2858:  MOVWF  01
285A:  MOVLW  00
285C:  ADDWFC x82,W
285E:  MOVWF  03
2860:  MOVF   01,W
2862:  ADDLW  69
2864:  MOVWF  FE9
2866:  MOVLW  00
2868:  ADDWFC 03,W
286A:  MOVWF  FEA
286C:  MOVFF  FEF,135
....................         provi[5] = motor[i][5]; 
2870:  MOVF   x7D,W
2872:  MULLW  07
2874:  MOVF   FF3,W
2876:  CLRF   x82
2878:  MOVWF  x81
287A:  MOVLW  05
287C:  ADDWF  x81,W
287E:  MOVWF  01
2880:  MOVLW  00
2882:  ADDWFC x82,W
2884:  MOVWF  03
2886:  MOVF   01,W
2888:  ADDLW  69
288A:  MOVWF  FE9
288C:  MOVLW  00
288E:  ADDWFC 03,W
2890:  MOVWF  FEA
2892:  MOVFF  FEF,136
....................  
....................         pasos[i] = (signed int32)atof(provi); 
2896:  MOVF   x7D,W
2898:  MULLW  04
289A:  MOVF   FF3,W
289C:  CLRF   03
289E:  ADDLW  95
28A0:  MOVWF  01
28A2:  MOVLW  00
28A4:  ADDWFC 03,F
28A6:  MOVFF  01,181
28AA:  MOVFF  03,182
28AE:  MOVLW  01
28B0:  MOVWF  x84
28B2:  MOVLW  31
28B4:  MOVWF  x83
28B6:  CLRF   x86
28B8:  CLRF   x85
28BA:  MOVLB  0
28BC:  BRA    2494
28BE:  MOVFF  03,186
28C2:  MOVFF  02,185
28C6:  MOVFF  01,184
28CA:  MOVFF  00,183
28CE:  BRA    26E4
28D0:  MOVFF  182,FEA
28D4:  MOVFF  181,FE9
28D8:  MOVFF  00,FEF
28DC:  MOVFF  01,FEC
28E0:  MOVFF  02,FEC
28E4:  MOVFF  03,FEC
....................         veloprovi = motor[i][6]; 
28E8:  MOVLB  1
28EA:  MOVF   x7D,W
28EC:  MULLW  07
28EE:  MOVF   FF3,W
28F0:  CLRF   x82
28F2:  MOVWF  x81
28F4:  MOVLW  06
28F6:  ADDWF  x81,W
28F8:  MOVWF  01
28FA:  MOVLW  00
28FC:  ADDWFC x82,W
28FE:  MOVWF  03
2900:  MOVF   01,W
2902:  ADDLW  69
2904:  MOVWF  FE9
2906:  MOVLW  00
2908:  ADDWFC 03,W
290A:  MOVWF  FEA
290C:  MOVFF  FEF,137
....................         velocidad[i] = veloprovi - 48;           
2910:  CLRF   03
2912:  MOVF   x7D,W
2914:  ADDLW  AD
2916:  MOVWF  FE9
2918:  MOVLW  00
291A:  ADDWFC 03,W
291C:  MOVWF  FEA
291E:  MOVLW  30
2920:  SUBWF  x37,W
2922:  MOVWF  FEF
....................          
....................         //Correccion de velocidades 
....................         if (i == 0) velocidad[0] = velocidad[0] * 3; 
2924:  MOVF   x7D,F
2926:  BNZ   2934
2928:  MOVLB  0
292A:  MOVF   xAD,W
292C:  MULLW  03
292E:  MOVFF  FF3,AD
2932:  MOVLB  1
....................         if (i == 1) velocidad[1] = velocidad[1] * 2; 
2934:  DECFSZ x7D,W
2936:  BRA    2940
2938:  BCF    FD8.0
293A:  MOVLB  0
293C:  RLCF   xAE,F
293E:  MOVLB  1
....................         if (i == 3) velocidad[3] = velocidad[3] * 10; 
2940:  MOVF   x7D,W
2942:  SUBLW  03
2944:  BNZ   2952
2946:  MOVLB  0
2948:  MOVF   xB0,W
294A:  MULLW  0A
294C:  MOVFF  FF3,B0
2950:  MOVLB  1
....................  
....................         veloprovi = 0; 
2952:  CLRF   x37
....................         velofija[i] = velocidad[i]; 
2954:  CLRF   03
2956:  MOVF   x7D,W
2958:  ADDLW  B3
295A:  MOVWF  01
295C:  MOVLW  00
295E:  ADDWFC 03,F
2960:  MOVFF  03,182
2964:  CLRF   03
2966:  MOVF   x7D,W
2968:  ADDLW  AD
296A:  MOVWF  FE9
296C:  MOVLW  00
296E:  ADDWFC 03,W
2970:  MOVWF  FEA
2972:  MOVFF  FEF,183
2976:  MOVFF  182,FEA
297A:  MOVFF  01,FE9
297E:  MOVFF  183,FEF
2982:  INCF   x7D,F
2984:  BRA    27B6
....................  
....................     } 
....................   
....................     flagTimer = 1; 
2986:  MOVLW  01
2988:  MOVLB  0
298A:  MOVWF  x61
....................     cantCaracteres = 0; 
298C:  CLRF   52
298E:  CLRF   16
2990:  BTFSC  FF2.7
2992:  BSF    16.7
2994:  BCF    FF2.7
....................     inicbuff(); 
2996:  CALL   0CB4
299A:  BTFSC  16.7
299C:  BSF    FF2.7
....................     set_timer0(interrupVel); 
299E:  CLRF   FD7
29A0:  MOVFF  138,FD6
....................     enable_interrupts(INT_RDA); 
29A4:  BSF    F9D.5
....................     flagComando = 0; // Desactivo flag de comando pendiente. 
29A6:  CLRF   55
29A8:  GOTO   2E42 (RETURN)
....................  
.................... } 
....................  
.................... void armarPaquete(void) { 
....................  
....................     char paqueteBase[51] = "*1+0000032+0000033+0000034+0000035+0000036+000003*"; 
*
16DA:  MOVLW  2A
16DC:  MOVLB  1
16DE:  MOVWF  x7D
16E0:  MOVLW  31
16E2:  MOVWF  x7E
16E4:  MOVLW  2B
16E6:  MOVWF  x7F
16E8:  MOVLW  30
16EA:  MOVWF  x80
16EC:  MOVWF  x81
16EE:  MOVWF  x82
16F0:  MOVWF  x83
16F2:  MOVWF  x84
16F4:  MOVLW  33
16F6:  MOVWF  x85
16F8:  MOVLW  32
16FA:  MOVWF  x86
16FC:  MOVLW  2B
16FE:  MOVWF  x87
1700:  MOVLW  30
1702:  MOVWF  x88
1704:  MOVWF  x89
1706:  MOVWF  x8A
1708:  MOVWF  x8B
170A:  MOVWF  x8C
170C:  MOVLW  33
170E:  MOVWF  x8D
1710:  MOVWF  x8E
1712:  MOVLW  2B
1714:  MOVWF  x8F
1716:  MOVLW  30
1718:  MOVWF  x90
171A:  MOVWF  x91
171C:  MOVWF  x92
171E:  MOVWF  x93
1720:  MOVWF  x94
1722:  MOVLW  33
1724:  MOVWF  x95
1726:  MOVLW  34
1728:  MOVWF  x96
172A:  MOVLW  2B
172C:  MOVWF  x97
172E:  MOVLW  30
1730:  MOVWF  x98
1732:  MOVWF  x99
1734:  MOVWF  x9A
1736:  MOVWF  x9B
1738:  MOVWF  x9C
173A:  MOVLW  33
173C:  MOVWF  x9D
173E:  MOVLW  35
1740:  MOVWF  x9E
1742:  MOVLW  2B
1744:  MOVWF  x9F
1746:  MOVLW  30
1748:  MOVWF  xA0
174A:  MOVWF  xA1
174C:  MOVWF  xA2
174E:  MOVWF  xA3
1750:  MOVWF  xA4
1752:  MOVLW  33
1754:  MOVWF  xA5
1756:  MOVLW  36
1758:  MOVWF  xA6
175A:  MOVLW  2B
175C:  MOVWF  xA7
175E:  MOVLW  30
1760:  MOVWF  xA8
1762:  MOVWF  xA9
1764:  MOVWF  xAA
1766:  MOVWF  xAB
1768:  MOVWF  xAC
176A:  MOVLW  33
176C:  MOVWF  xAD
176E:  MOVLW  2A
1770:  MOVWF  xAE
1772:  CLRF   xAF
....................     char bufferPasos[6] = "00000"; 
1774:  MOVLW  30
1776:  MOVWF  xB0
1778:  MOVWF  xB1
177A:  MOVWF  xB2
177C:  MOVWF  xB3
177E:  MOVWF  xB4
1780:  CLRF   xB5
....................  
....................     for (int j = 0; j < 6; j++) { 
1782:  CLRF   xB6
1784:  MOVF   xB6,W
1786:  SUBLW  05
1788:  BNC   1840
....................          
....................         if (flagPaquetePasosDados == 1) { 
178A:  MOVLB  0
178C:  DECFSZ x68,W
178E:  BRA    17E8
....................             arrayPasos[j] = pasosDados[j]; 
1790:  MOVLB  1
1792:  MOVF   xB6,W
1794:  MULLW  04
1796:  MOVF   FF3,W
1798:  CLRF   03
179A:  ADDLW  19
179C:  MOVWF  01
179E:  MOVLW  01
17A0:  ADDWFC 03,F
17A2:  MOVFF  01,1B9
17A6:  MOVFF  03,1BA
17AA:  MOVF   xB6,W
17AC:  MULLW  04
17AE:  MOVF   FF3,W
17B0:  CLRF   03
17B2:  ADDLW  01
17B4:  MOVWF  FE9
17B6:  MOVLW  01
17B8:  ADDWFC 03,W
17BA:  MOVWF  FEA
17BC:  MOVFF  FEF,00
17C0:  MOVFF  FEC,01
17C4:  MOVFF  FEC,02
17C8:  MOVFF  FEC,03
17CC:  MOVFF  1BA,FEA
17D0:  MOVFF  1B9,FE9
17D4:  MOVFF  00,FEF
17D8:  MOVFF  01,FEC
17DC:  MOVFF  02,FEC
17E0:  MOVFF  03,FEC
....................         } else { 
17E4:  BRA    183C
17E6:  MOVLB  0
....................             arrayPasos[j] = contPasos[j]; 
17E8:  MOVLB  1
17EA:  MOVF   xB6,W
17EC:  MULLW  04
17EE:  MOVF   FF3,W
17F0:  CLRF   03
17F2:  ADDLW  19
17F4:  MOVWF  01
17F6:  MOVLW  01
17F8:  ADDWFC 03,F
17FA:  MOVFF  01,1B9
17FE:  MOVFF  03,1BA
1802:  MOVF   xB6,W
1804:  MULLW  04
1806:  MOVF   FF3,W
1808:  CLRF   03
180A:  ADDLW  B9
180C:  MOVWF  FE9
180E:  MOVLW  00
1810:  ADDWFC 03,W
1812:  MOVWF  FEA
1814:  MOVFF  FEF,00
1818:  MOVFF  FEC,01
181C:  MOVFF  FEC,02
1820:  MOVFF  FEC,03
1824:  MOVFF  1BA,FEA
1828:  MOVFF  1B9,FE9
182C:  MOVFF  00,FEF
1830:  MOVFF  01,FEC
1834:  MOVFF  02,FEC
1838:  MOVFF  03,FEC
....................         } 
183C:  INCF   xB6,F
183E:  BRA    1784
....................          
....................     } 
....................  
....................     flagPaquetePasosDados = 0; 
1840:  MOVLB  0
1842:  CLRF   x68
....................  
....................     for (int l = 0; l < 6; l++) { 
1844:  MOVLB  1
1846:  CLRF   xB7
1848:  MOVF   xB7,W
184A:  SUBLW  05
184C:  BTFSS  FD8.0
184E:  BRA    1E0C
....................  
....................         itoa(arrayPasos[l], 10, bufferPasos); 
1850:  MOVF   xB7,W
1852:  MULLW  04
1854:  MOVF   FF3,W
1856:  CLRF   03
1858:  ADDLW  19
185A:  MOVWF  FE9
185C:  MOVLW  01
185E:  ADDWFC 03,W
1860:  MOVWF  FEA
1862:  MOVFF  FEF,1B9
1866:  MOVFF  FEC,1BA
186A:  MOVFF  FEC,1BB
186E:  MOVFF  FEC,1BC
1872:  MOVFF  1BC,1C0
1876:  MOVFF  1BB,1BF
187A:  MOVFF  1BA,1BE
187E:  MOVFF  1B9,1BD
1882:  MOVLW  0A
1884:  MOVWF  xC1
1886:  MOVLW  01
1888:  MOVWF  xC3
188A:  MOVLW  B0
188C:  MOVWF  xC2
188E:  MOVLB  0
1890:  BRA    150C
....................  
....................         if (arrayPasos[l] >= 10000) { 
1892:  MOVLB  1
1894:  MOVF   xB7,W
1896:  MULLW  04
1898:  MOVF   FF3,W
189A:  CLRF   03
189C:  ADDLW  19
189E:  MOVWF  FE9
18A0:  MOVLW  01
18A2:  ADDWFC 03,W
18A4:  MOVWF  FEA
18A6:  MOVFF  FEF,1B9
18AA:  MOVFF  FEC,1BA
18AE:  MOVFF  FEC,1BB
18B2:  MOVFF  FEC,1BC
18B6:  BTFSC  xBC.7
18B8:  BRA    194C
18BA:  MOVF   xBC,F
18BC:  BNZ   18D2
18BE:  MOVF   xBB,F
18C0:  BNZ   18D2
18C2:  MOVF   xBA,W
18C4:  SUBLW  26
18C6:  BC    194C
18C8:  XORLW  FF
18CA:  BNZ   18D2
18CC:  MOVF   xB9,W
18CE:  SUBLW  0F
18D0:  BC    194C
....................             paqueteBase[l * 8 + 3] = bufferPasos[0]; 
18D2:  MOVF   xB7,W
18D4:  MULLW  08
18D6:  MOVF   FF3,W
18D8:  ADDLW  03
18DA:  CLRF   03
18DC:  ADDLW  7D
18DE:  MOVWF  FE9
18E0:  MOVLW  01
18E2:  ADDWFC 03,W
18E4:  MOVWF  FEA
18E6:  MOVFF  1B0,FEF
....................             paqueteBase[l * 8 + 4] = bufferPasos[1]; 
18EA:  MOVF   xB7,W
18EC:  MULLW  08
18EE:  MOVF   FF3,W
18F0:  ADDLW  04
18F2:  CLRF   03
18F4:  ADDLW  7D
18F6:  MOVWF  FE9
18F8:  MOVLW  01
18FA:  ADDWFC 03,W
18FC:  MOVWF  FEA
18FE:  MOVFF  1B1,FEF
....................             paqueteBase[l * 8 + 5] = bufferPasos[2]; 
1902:  MOVF   xB7,W
1904:  MULLW  08
1906:  MOVF   FF3,W
1908:  ADDLW  05
190A:  CLRF   03
190C:  ADDLW  7D
190E:  MOVWF  FE9
1910:  MOVLW  01
1912:  ADDWFC 03,W
1914:  MOVWF  FEA
1916:  MOVFF  1B2,FEF
....................             paqueteBase[l * 8 + 6] = bufferPasos[3]; 
191A:  MOVF   xB7,W
191C:  MULLW  08
191E:  MOVF   FF3,W
1920:  ADDLW  06
1922:  CLRF   03
1924:  ADDLW  7D
1926:  MOVWF  FE9
1928:  MOVLW  01
192A:  ADDWFC 03,W
192C:  MOVWF  FEA
192E:  MOVFF  1B3,FEF
....................             paqueteBase[l * 8 + 7] = bufferPasos[4]; 
1932:  MOVF   xB7,W
1934:  MULLW  08
1936:  MOVF   FF3,W
1938:  ADDLW  07
193A:  CLRF   03
193C:  ADDLW  7D
193E:  MOVWF  FE9
1940:  MOVLW  01
1942:  ADDWFC 03,W
1944:  MOVWF  FEA
1946:  MOVFF  1B4,FEF
....................         } else if (arrayPasos[l] < 10000 && arrayPasos[l] > 999) { 
194A:  BRA    1DAC
194C:  MOVF   xB7,W
194E:  MULLW  04
1950:  MOVF   FF3,W
1952:  CLRF   03
1954:  ADDLW  19
1956:  MOVWF  FE9
1958:  MOVLW  01
195A:  ADDWFC 03,W
195C:  MOVWF  FEA
195E:  MOVFF  FEF,1B9
1962:  MOVFF  FEC,1BA
1966:  MOVFF  FEC,1BB
196A:  MOVFF  FEC,1BC
196E:  BTFSC  xBC.7
1970:  BRA    1988
1972:  MOVF   xBC,F
1974:  BNZ   1A40
1976:  MOVF   xBB,F
1978:  BNZ   1A40
197A:  MOVF   xBA,W
197C:  SUBLW  27
197E:  BNC   1A40
1980:  BNZ   1988
1982:  MOVF   xB9,W
1984:  SUBLW  0F
1986:  BNC   1A40
1988:  MOVF   xB7,W
198A:  MULLW  04
198C:  MOVF   FF3,W
198E:  CLRF   03
1990:  ADDLW  19
1992:  MOVWF  FE9
1994:  MOVLW  01
1996:  ADDWFC 03,W
1998:  MOVWF  FEA
199A:  MOVFF  FEF,1B9
199E:  MOVFF  FEC,1BA
19A2:  MOVFF  FEC,1BB
19A6:  MOVFF  FEC,1BC
19AA:  BTFSC  xBC.7
19AC:  BRA    1A40
19AE:  MOVF   xBC,F
19B0:  BNZ   19C6
19B2:  MOVF   xBB,F
19B4:  BNZ   19C6
19B6:  MOVF   xBA,W
19B8:  SUBLW  02
19BA:  BC    1A40
19BC:  XORLW  FF
19BE:  BNZ   19C6
19C0:  MOVF   xB9,W
19C2:  SUBLW  E7
19C4:  BC    1A40
....................             paqueteBase[l * 8 + 3] = '0'; 
19C6:  MOVF   xB7,W
19C8:  MULLW  08
19CA:  MOVF   FF3,W
19CC:  ADDLW  03
19CE:  CLRF   03
19D0:  ADDLW  7D
19D2:  MOVWF  FE9
19D4:  MOVLW  01
19D6:  ADDWFC 03,W
19D8:  MOVWF  FEA
19DA:  MOVLW  30
19DC:  MOVWF  FEF
....................             paqueteBase[l * 8 + 4] = bufferPasos[0]; 
19DE:  MOVF   xB7,W
19E0:  MULLW  08
19E2:  MOVF   FF3,W
19E4:  ADDLW  04
19E6:  CLRF   03
19E8:  ADDLW  7D
19EA:  MOVWF  FE9
19EC:  MOVLW  01
19EE:  ADDWFC 03,W
19F0:  MOVWF  FEA
19F2:  MOVFF  1B0,FEF
....................             paqueteBase[l * 8 + 5] = bufferPasos[1]; 
19F6:  MOVF   xB7,W
19F8:  MULLW  08
19FA:  MOVF   FF3,W
19FC:  ADDLW  05
19FE:  CLRF   03
1A00:  ADDLW  7D
1A02:  MOVWF  FE9
1A04:  MOVLW  01
1A06:  ADDWFC 03,W
1A08:  MOVWF  FEA
1A0A:  MOVFF  1B1,FEF
....................             paqueteBase[l * 8 + 6] = bufferPasos[2]; 
1A0E:  MOVF   xB7,W
1A10:  MULLW  08
1A12:  MOVF   FF3,W
1A14:  ADDLW  06
1A16:  CLRF   03
1A18:  ADDLW  7D
1A1A:  MOVWF  FE9
1A1C:  MOVLW  01
1A1E:  ADDWFC 03,W
1A20:  MOVWF  FEA
1A22:  MOVFF  1B2,FEF
....................             paqueteBase[l * 8 + 7] = bufferPasos[3]; 
1A26:  MOVF   xB7,W
1A28:  MULLW  08
1A2A:  MOVF   FF3,W
1A2C:  ADDLW  07
1A2E:  CLRF   03
1A30:  ADDLW  7D
1A32:  MOVWF  FE9
1A34:  MOVLW  01
1A36:  ADDWFC 03,W
1A38:  MOVWF  FEA
1A3A:  MOVFF  1B3,FEF
....................         } else if (arrayPasos[l] < 1000 && arrayPasos[l] > 99) { 
1A3E:  BRA    1DAC
1A40:  MOVF   xB7,W
1A42:  MULLW  04
1A44:  MOVF   FF3,W
1A46:  CLRF   03
1A48:  ADDLW  19
1A4A:  MOVWF  FE9
1A4C:  MOVLW  01
1A4E:  ADDWFC 03,W
1A50:  MOVWF  FEA
1A52:  MOVFF  FEF,1B9
1A56:  MOVFF  FEC,1BA
1A5A:  MOVFF  FEC,1BB
1A5E:  MOVFF  FEC,1BC
1A62:  BTFSC  xBC.7
1A64:  BRA    1A7C
1A66:  MOVF   xBC,F
1A68:  BNZ   1B2E
1A6A:  MOVF   xBB,F
1A6C:  BNZ   1B2E
1A6E:  MOVF   xBA,W
1A70:  SUBLW  03
1A72:  BNC   1B2E
1A74:  BNZ   1A7C
1A76:  MOVF   xB9,W
1A78:  SUBLW  E7
1A7A:  BNC   1B2E
1A7C:  MOVF   xB7,W
1A7E:  MULLW  04
1A80:  MOVF   FF3,W
1A82:  CLRF   03
1A84:  ADDLW  19
1A86:  MOVWF  FE9
1A88:  MOVLW  01
1A8A:  ADDWFC 03,W
1A8C:  MOVWF  FEA
1A8E:  MOVFF  FEF,1B9
1A92:  MOVFF  FEC,1BA
1A96:  MOVFF  FEC,1BB
1A9A:  MOVFF  FEC,1BC
1A9E:  BTFSC  xBC.7
1AA0:  BRA    1B2E
1AA2:  MOVF   xBC,F
1AA4:  BNZ   1AB4
1AA6:  MOVF   xBB,F
1AA8:  BNZ   1AB4
1AAA:  MOVF   xBA,F
1AAC:  BNZ   1AB4
1AAE:  MOVF   xB9,W
1AB0:  SUBLW  63
1AB2:  BC    1B2E
....................             paqueteBase[l * 8 + 3] = '0'; 
1AB4:  MOVF   xB7,W
1AB6:  MULLW  08
1AB8:  MOVF   FF3,W
1ABA:  ADDLW  03
1ABC:  CLRF   03
1ABE:  ADDLW  7D
1AC0:  MOVWF  FE9
1AC2:  MOVLW  01
1AC4:  ADDWFC 03,W
1AC6:  MOVWF  FEA
1AC8:  MOVLW  30
1ACA:  MOVWF  FEF
....................             paqueteBase[l * 8 + 4] = '0'; 
1ACC:  MOVF   xB7,W
1ACE:  MULLW  08
1AD0:  MOVF   FF3,W
1AD2:  ADDLW  04
1AD4:  CLRF   03
1AD6:  ADDLW  7D
1AD8:  MOVWF  FE9
1ADA:  MOVLW  01
1ADC:  ADDWFC 03,W
1ADE:  MOVWF  FEA
1AE0:  MOVLW  30
1AE2:  MOVWF  FEF
....................             paqueteBase[l * 8 + 5] = bufferPasos[0]; 
1AE4:  MOVF   xB7,W
1AE6:  MULLW  08
1AE8:  MOVF   FF3,W
1AEA:  ADDLW  05
1AEC:  CLRF   03
1AEE:  ADDLW  7D
1AF0:  MOVWF  FE9
1AF2:  MOVLW  01
1AF4:  ADDWFC 03,W
1AF6:  MOVWF  FEA
1AF8:  MOVFF  1B0,FEF
....................             paqueteBase[l * 8 + 6] = bufferPasos[1]; 
1AFC:  MOVF   xB7,W
1AFE:  MULLW  08
1B00:  MOVF   FF3,W
1B02:  ADDLW  06
1B04:  CLRF   03
1B06:  ADDLW  7D
1B08:  MOVWF  FE9
1B0A:  MOVLW  01
1B0C:  ADDWFC 03,W
1B0E:  MOVWF  FEA
1B10:  MOVFF  1B1,FEF
....................             paqueteBase[l * 8 + 7] = bufferPasos[2]; 
1B14:  MOVF   xB7,W
1B16:  MULLW  08
1B18:  MOVF   FF3,W
1B1A:  ADDLW  07
1B1C:  CLRF   03
1B1E:  ADDLW  7D
1B20:  MOVWF  FE9
1B22:  MOVLW  01
1B24:  ADDWFC 03,W
1B26:  MOVWF  FEA
1B28:  MOVFF  1B2,FEF
....................         } else if (arrayPasos[l] < 100 && arrayPasos[l] > 9) { 
1B2C:  BRA    1DAC
1B2E:  MOVF   xB7,W
1B30:  MULLW  04
1B32:  MOVF   FF3,W
1B34:  CLRF   03
1B36:  ADDLW  19
1B38:  MOVWF  FE9
1B3A:  MOVLW  01
1B3C:  ADDWFC 03,W
1B3E:  MOVWF  FEA
1B40:  MOVFF  FEF,1B9
1B44:  MOVFF  FEC,1BA
1B48:  MOVFF  FEC,1BB
1B4C:  MOVFF  FEC,1BC
1B50:  BTFSC  xBC.7
1B52:  BRA    1B66
1B54:  MOVF   xBC,F
1B56:  BNZ   1C18
1B58:  MOVF   xBB,F
1B5A:  BNZ   1C18
1B5C:  MOVF   xBA,F
1B5E:  BNZ   1C18
1B60:  MOVF   xB9,W
1B62:  SUBLW  63
1B64:  BNC   1C18
1B66:  MOVF   xB7,W
1B68:  MULLW  04
1B6A:  MOVF   FF3,W
1B6C:  CLRF   03
1B6E:  ADDLW  19
1B70:  MOVWF  FE9
1B72:  MOVLW  01
1B74:  ADDWFC 03,W
1B76:  MOVWF  FEA
1B78:  MOVFF  FEF,1B9
1B7C:  MOVFF  FEC,1BA
1B80:  MOVFF  FEC,1BB
1B84:  MOVFF  FEC,1BC
1B88:  BTFSC  xBC.7
1B8A:  BRA    1C18
1B8C:  MOVF   xBC,F
1B8E:  BNZ   1B9E
1B90:  MOVF   xBB,F
1B92:  BNZ   1B9E
1B94:  MOVF   xBA,F
1B96:  BNZ   1B9E
1B98:  MOVF   xB9,W
1B9A:  SUBLW  09
1B9C:  BC    1C18
....................             paqueteBase[l * 8 + 3] = '0'; 
1B9E:  MOVF   xB7,W
1BA0:  MULLW  08
1BA2:  MOVF   FF3,W
1BA4:  ADDLW  03
1BA6:  CLRF   03
1BA8:  ADDLW  7D
1BAA:  MOVWF  FE9
1BAC:  MOVLW  01
1BAE:  ADDWFC 03,W
1BB0:  MOVWF  FEA
1BB2:  MOVLW  30
1BB4:  MOVWF  FEF
....................             paqueteBase[l * 8 + 4] = '0'; 
1BB6:  MOVF   xB7,W
1BB8:  MULLW  08
1BBA:  MOVF   FF3,W
1BBC:  ADDLW  04
1BBE:  CLRF   03
1BC0:  ADDLW  7D
1BC2:  MOVWF  FE9
1BC4:  MOVLW  01
1BC6:  ADDWFC 03,W
1BC8:  MOVWF  FEA
1BCA:  MOVLW  30
1BCC:  MOVWF  FEF
....................             paqueteBase[l * 8 + 5] = '0'; 
1BCE:  MOVF   xB7,W
1BD0:  MULLW  08
1BD2:  MOVF   FF3,W
1BD4:  ADDLW  05
1BD6:  CLRF   03
1BD8:  ADDLW  7D
1BDA:  MOVWF  FE9
1BDC:  MOVLW  01
1BDE:  ADDWFC 03,W
1BE0:  MOVWF  FEA
1BE2:  MOVLW  30
1BE4:  MOVWF  FEF
....................             paqueteBase[l * 8 + 6] = bufferPasos[0]; 
1BE6:  MOVF   xB7,W
1BE8:  MULLW  08
1BEA:  MOVF   FF3,W
1BEC:  ADDLW  06
1BEE:  CLRF   03
1BF0:  ADDLW  7D
1BF2:  MOVWF  FE9
1BF4:  MOVLW  01
1BF6:  ADDWFC 03,W
1BF8:  MOVWF  FEA
1BFA:  MOVFF  1B0,FEF
....................             paqueteBase[l * 8 + 7] = bufferPasos[1]; 
1BFE:  MOVF   xB7,W
1C00:  MULLW  08
1C02:  MOVF   FF3,W
1C04:  ADDLW  07
1C06:  CLRF   03
1C08:  ADDLW  7D
1C0A:  MOVWF  FE9
1C0C:  MOVLW  01
1C0E:  ADDWFC 03,W
1C10:  MOVWF  FEA
1C12:  MOVFF  1B1,FEF
....................         } else if (arrayPasos[l] < 10 && arrayPasos[l] > 0) { 
1C16:  BRA    1DAC
1C18:  MOVF   xB7,W
1C1A:  MULLW  04
1C1C:  MOVF   FF3,W
1C1E:  CLRF   03
1C20:  ADDLW  19
1C22:  MOVWF  FE9
1C24:  MOVLW  01
1C26:  ADDWFC 03,W
1C28:  MOVWF  FEA
1C2A:  MOVFF  FEF,1B9
1C2E:  MOVFF  FEC,1BA
1C32:  MOVFF  FEC,1BB
1C36:  MOVFF  FEC,1BC
1C3A:  BTFSC  xBC.7
1C3C:  BRA    1C50
1C3E:  MOVF   xBC,F
1C40:  BNZ   1D02
1C42:  MOVF   xBB,F
1C44:  BNZ   1D02
1C46:  MOVF   xBA,F
1C48:  BNZ   1D02
1C4A:  MOVF   xB9,W
1C4C:  SUBLW  09
1C4E:  BNC   1D02
1C50:  MOVF   xB7,W
1C52:  MULLW  04
1C54:  MOVF   FF3,W
1C56:  CLRF   03
1C58:  ADDLW  19
1C5A:  MOVWF  FE9
1C5C:  MOVLW  01
1C5E:  ADDWFC 03,W
1C60:  MOVWF  FEA
1C62:  MOVFF  FEF,1B9
1C66:  MOVFF  FEC,1BA
1C6A:  MOVFF  FEC,1BB
1C6E:  MOVFF  FEC,1BC
1C72:  BTFSC  xBC.7
1C74:  BRA    1D02
1C76:  MOVF   xBC,F
1C78:  BNZ   1C88
1C7A:  MOVF   xBB,F
1C7C:  BNZ   1C88
1C7E:  MOVF   xBA,F
1C80:  BNZ   1C88
1C82:  MOVF   xB9,W
1C84:  SUBLW  00
1C86:  BC    1D02
....................             paqueteBase[l * 8 + 3] = '0'; 
1C88:  MOVF   xB7,W
1C8A:  MULLW  08
1C8C:  MOVF   FF3,W
1C8E:  ADDLW  03
1C90:  CLRF   03
1C92:  ADDLW  7D
1C94:  MOVWF  FE9
1C96:  MOVLW  01
1C98:  ADDWFC 03,W
1C9A:  MOVWF  FEA
1C9C:  MOVLW  30
1C9E:  MOVWF  FEF
....................             paqueteBase[l * 8 + 4] = '0'; 
1CA0:  MOVF   xB7,W
1CA2:  MULLW  08
1CA4:  MOVF   FF3,W
1CA6:  ADDLW  04
1CA8:  CLRF   03
1CAA:  ADDLW  7D
1CAC:  MOVWF  FE9
1CAE:  MOVLW  01
1CB0:  ADDWFC 03,W
1CB2:  MOVWF  FEA
1CB4:  MOVLW  30
1CB6:  MOVWF  FEF
....................             paqueteBase[l * 8 + 5] = '0'; 
1CB8:  MOVF   xB7,W
1CBA:  MULLW  08
1CBC:  MOVF   FF3,W
1CBE:  ADDLW  05
1CC0:  CLRF   03
1CC2:  ADDLW  7D
1CC4:  MOVWF  FE9
1CC6:  MOVLW  01
1CC8:  ADDWFC 03,W
1CCA:  MOVWF  FEA
1CCC:  MOVLW  30
1CCE:  MOVWF  FEF
....................             paqueteBase[l * 8 + 6] = '0'; 
1CD0:  MOVF   xB7,W
1CD2:  MULLW  08
1CD4:  MOVF   FF3,W
1CD6:  ADDLW  06
1CD8:  CLRF   03
1CDA:  ADDLW  7D
1CDC:  MOVWF  FE9
1CDE:  MOVLW  01
1CE0:  ADDWFC 03,W
1CE2:  MOVWF  FEA
1CE4:  MOVLW  30
1CE6:  MOVWF  FEF
....................             paqueteBase[l * 8 + 7] = bufferPasos[0]; 
1CE8:  MOVF   xB7,W
1CEA:  MULLW  08
1CEC:  MOVF   FF3,W
1CEE:  ADDLW  07
1CF0:  CLRF   03
1CF2:  ADDLW  7D
1CF4:  MOVWF  FE9
1CF6:  MOVLW  01
1CF8:  ADDWFC 03,W
1CFA:  MOVWF  FEA
1CFC:  MOVFF  1B0,FEF
....................         } else if (arrayPasos[l] == 0) { 
1D00:  BRA    1DAC
1D02:  MOVF   xB7,W
1D04:  MULLW  04
1D06:  MOVF   FF3,W
1D08:  CLRF   03
1D0A:  ADDLW  19
1D0C:  MOVWF  FE9
1D0E:  MOVLW  01
1D10:  ADDWFC 03,W
1D12:  MOVWF  FEA
1D14:  MOVFF  FEF,1B9
1D18:  MOVFF  FEC,1BA
1D1C:  MOVFF  FEC,1BB
1D20:  MOVFF  FEC,1BC
1D24:  MOVF   xB9,F
1D26:  BNZ   1DAC
1D28:  MOVF   xBA,F
1D2A:  BNZ   1DAC
1D2C:  MOVF   xBB,F
1D2E:  BNZ   1DAC
1D30:  MOVF   xBC,F
1D32:  BNZ   1DAC
....................             paqueteBase[l * 8 + 3] = '0'; 
1D34:  MOVF   xB7,W
1D36:  MULLW  08
1D38:  MOVF   FF3,W
1D3A:  ADDLW  03
1D3C:  CLRF   03
1D3E:  ADDLW  7D
1D40:  MOVWF  FE9
1D42:  MOVLW  01
1D44:  ADDWFC 03,W
1D46:  MOVWF  FEA
1D48:  MOVLW  30
1D4A:  MOVWF  FEF
....................             paqueteBase[l * 8 + 4] = '0'; 
1D4C:  MOVF   xB7,W
1D4E:  MULLW  08
1D50:  MOVF   FF3,W
1D52:  ADDLW  04
1D54:  CLRF   03
1D56:  ADDLW  7D
1D58:  MOVWF  FE9
1D5A:  MOVLW  01
1D5C:  ADDWFC 03,W
1D5E:  MOVWF  FEA
1D60:  MOVLW  30
1D62:  MOVWF  FEF
....................             paqueteBase[l * 8 + 5] = '0'; 
1D64:  MOVF   xB7,W
1D66:  MULLW  08
1D68:  MOVF   FF3,W
1D6A:  ADDLW  05
1D6C:  CLRF   03
1D6E:  ADDLW  7D
1D70:  MOVWF  FE9
1D72:  MOVLW  01
1D74:  ADDWFC 03,W
1D76:  MOVWF  FEA
1D78:  MOVLW  30
1D7A:  MOVWF  FEF
....................             paqueteBase[l * 8 + 6] = '0'; 
1D7C:  MOVF   xB7,W
1D7E:  MULLW  08
1D80:  MOVF   FF3,W
1D82:  ADDLW  06
1D84:  CLRF   03
1D86:  ADDLW  7D
1D88:  MOVWF  FE9
1D8A:  MOVLW  01
1D8C:  ADDWFC 03,W
1D8E:  MOVWF  FEA
1D90:  MOVLW  30
1D92:  MOVWF  FEF
....................             paqueteBase[l * 8 + 7] = '0'; 
1D94:  MOVF   xB7,W
1D96:  MULLW  08
1D98:  MOVF   FF3,W
1D9A:  ADDLW  07
1D9C:  CLRF   03
1D9E:  ADDLW  7D
1DA0:  MOVWF  FE9
1DA2:  MOVLW  01
1DA4:  ADDWFC 03,W
1DA6:  MOVWF  FEA
1DA8:  MOVLW  30
1DAA:  MOVWF  FEF
....................         } 
....................  
....................         paqueteBase[l * 8 + 2] = signoPasos[l]; 
1DAC:  MOVF   xB7,W
1DAE:  MULLW  08
1DB0:  MOVF   FF3,W
1DB2:  ADDLW  02
1DB4:  CLRF   03
1DB6:  ADDLW  7D
1DB8:  MOVWF  01
1DBA:  MOVLW  01
1DBC:  ADDWFC 03,F
1DBE:  MOVFF  03,1BA
1DC2:  CLRF   03
1DC4:  MOVF   xB7,W
1DC6:  ADDLW  6B
1DC8:  MOVWF  FE9
1DCA:  MOVLW  01
1DCC:  ADDWFC 03,W
1DCE:  MOVWF  FEA
1DD0:  MOVFF  FEF,1BB
1DD4:  MOVFF  1BA,FEA
1DD8:  MOVFF  01,FE9
1DDC:  MOVFF  1BB,FEF
....................         bufferPasos = "00000"; 
1DE0:  MOVLW  01
1DE2:  MOVWF  FEA
1DE4:  MOVLW  B0
1DE6:  MOVWF  FE9
1DE8:  MOVFF  FF2,1B9
1DEC:  BCF    FF2.7
1DEE:  MOVLW  00
1DF0:  MOVLB  0
1DF2:  CALL   00A2
1DF6:  TBLRD*-
1DF8:  TBLRD*+
1DFA:  MOVF   FF5,W
1DFC:  MOVWF  FEE
1DFE:  IORLW  00
1E00:  BNZ   1DF8
1E02:  MOVLB  1
1E04:  BTFSC  xB9.7
1E06:  BSF    FF2.7
1E08:  INCF   xB7,F
1E0A:  BRA    1848
....................  
....................     } 
....................  
....................     for (int i = 0; i < 6; i++) { 
1E0C:  CLRF   xB8
1E0E:  MOVF   xB8,W
1E10:  SUBLW  05
1E12:  BNC   1E2A
....................         signoPasos[i] = '+'; 
1E14:  CLRF   03
1E16:  MOVF   xB8,W
1E18:  ADDLW  6B
1E1A:  MOVWF  FE9
1E1C:  MOVLW  01
1E1E:  ADDWFC 03,W
1E20:  MOVWF  FEA
1E22:  MOVLW  2B
1E24:  MOVWF  FEF
1E26:  INCF   xB8,F
1E28:  BRA    1E0E
....................     } 
....................  
....................     printf("%s", paqueteBase); 
1E2A:  MOVLW  01
1E2C:  MOVWF  FEA
1E2E:  MOVLW  7D
1E30:  MOVWF  FE9
1E32:  CLRF   16
1E34:  BTFSC  FF2.7
1E36:  BSF    16.7
1E38:  BCF    FF2.7
1E3A:  MOVLB  0
1E3C:  CALL   00FC
1E40:  BTFSC  16.7
1E42:  BSF    FF2.7
1E44:  GOTO   2E22 (RETURN)
....................  
.................... } 
....................  
.................... /*------------- INTERRUPCIONES -------------*/ 
....................  
.................... #int_rda 
....................  
.................... void serial_isr() { // Interrupción recepción serie USART 
....................  
....................     disable_interrupts(INT_TIMER0); 
*
0122:  BCF    FF2.5
....................      
....................     rcvchar = 0x00; // Inicializo caracter recibido             
0124:  CLRF   51
....................     rcvchar = getc(); // Almacena caracter 
0126:  BRA    00C2
0128:  MOVFF  01,51
....................  
....................     // Abrir mensaje 
....................     if (rcvchar == '#' && flagNumeral == 0) { 
012C:  MOVF   51,W
012E:  SUBLW  23
0130:  BNZ   013E
0132:  MOVF   57,F
0134:  BNZ   013E
....................         flagNumeral = 1; 
0136:  MOVLW  01
0138:  MOVWF  57
....................         return; 
013A:  BRA    0296
....................     } else if (rcvchar == '*' && flagAsterisco == 0) { 
013C:  BRA    0160
013E:  MOVF   51,W
0140:  SUBLW  2A
0142:  BNZ   0150
0144:  MOVF   56,F
0146:  BNZ   0150
....................         flagAsterisco = 1; 
0148:  MOVLW  01
014A:  MOVWF  56
....................         return; 
014C:  BRA    0296
....................     } else if (rcvchar == '$' && flagDollar == 0) { 
014E:  BRA    0160
0150:  MOVF   51,W
0152:  SUBLW  24
0154:  BNZ   0160
0156:  MOVF   58,F
0158:  BNZ   0160
....................         flagDollar = 1; 
015A:  MOVLW  01
015C:  MOVWF  58
....................         return; 
015E:  BRA    0296
....................     } 
....................  
....................     // Contenido mensaje 
....................     if (rcvchar != '#' && flagNumeral == 1) { 
0160:  MOVF   51,W
0162:  SUBLW  23
0164:  BZ    0170
0166:  DECFSZ 57,W
0168:  BRA    0170
....................  
....................         modoOperacion = rcvchar; 
016A:  MOVFF  51,54
....................  
....................     } else if (rcvchar != '*' && flagAsterisco == 1) { 
016E:  BRA    01E4
0170:  MOVF   51,W
0172:  SUBLW  2A
0174:  BZ    0192
0176:  DECFSZ 56,W
0178:  BRA    0192
....................  
....................         cbuff[xbuff++] = rcvchar; // Añade caracter recibido al Buffer 
017A:  MOVF   1E,W
017C:  INCF   1E,F
017E:  CLRF   03
0180:  ADDLW  1F
0182:  MOVWF  FE9
0184:  MOVLW  00
0186:  ADDWFC 03,W
0188:  MOVWF  FEA
018A:  MOVFF  51,FEF
....................         cantCaracteres++; 
018E:  INCF   52,F
....................  
....................     } else if (rcvchar != '$' && flagDollar == 1) { 
0190:  BRA    01E4
0192:  MOVF   51,W
0194:  SUBLW  24
0196:  BZ    01E4
0198:  DECFSZ 58,W
019A:  BRA    01E4
....................  
....................         if (rcvchar == 'I') { 
019C:  MOVF   51,W
019E:  SUBLW  49
01A0:  BNZ   01AA
....................             flagEstirar = 1; 
01A2:  MOVLW  01
01A4:  MOVWF  59
....................             return; 
01A6:  BRA    0296
....................         } else if (rcvchar == '0') { 
01A8:  BRA    01E4
01AA:  MOVF   51,W
01AC:  SUBLW  30
01AE:  BNZ   01B8
....................             flagHome = 1; 
01B0:  MOVLW  01
01B2:  MOVWF  x62
....................             return; 
01B4:  BRA    0296
....................         } else if (rcvchar == 'F') { 
01B6:  BRA    01E4
01B8:  MOVF   51,W
01BA:  SUBLW  46
01BC:  BNZ   01C8
....................             flagEstirar = 1; 
01BE:  MOVLW  01
01C0:  MOVWF  59
....................             flagF = 1; 
01C2:  MOVWF  x64
....................             return; 
01C4:  BRA    0296
....................         } else if (rcvchar == 'S') { 
01C6:  BRA    01E4
01C8:  MOVF   51,W
01CA:  SUBLW  53
01CC:  BNZ   01D8
....................             flagEstirar = 1; 
01CE:  MOVLW  01
01D0:  MOVWF  59
....................             flagS = 1; 
01D2:  MOVWF  x63
....................             return; 
01D4:  BRA    0296
....................         } else if (rcvchar == 'E') { 
01D6:  BRA    01E4
01D8:  MOVF   51,W
01DA:  SUBLW  45
01DC:  BNZ   01E4
....................             flagPasosDados = 1; 
01DE:  MOVLW  01
01E0:  MOVWF  x66
....................             return; 
01E2:  BRA    0296
....................         } 
....................  
....................     } 
....................  
....................     // Cerrar mensaje 
....................     if (rcvchar == '#' && flagNumeral == 1) { 
01E4:  MOVF   51,W
01E6:  SUBLW  23
01E8:  BNZ   0268
01EA:  DECFSZ 57,W
01EC:  BRA    0268
....................  
....................         printf("#OK-"); 
01EE:  MOVLW  9C
01F0:  MOVWF  FF6
01F2:  MOVLW  02
01F4:  MOVWF  FF7
01F6:  RCALL  00DA
....................         printf(&modoOperacion); 
01F8:  CLRF   FEA
01FA:  MOVLW  54
01FC:  MOVWF  FE9
01FE:  RCALL  00FC
....................         printf("#"); 
0200:  MOVLW  23
0202:  BTFSS  F9E.4
0204:  BRA    0202
0206:  MOVWF  FAD
....................  
....................         if (modoOperacion == 'J') { 
0208:  MOVF   54,W
020A:  SUBLW  4A
020C:  BNZ   021E
....................             output_high(LED_J); 
020E:  MOVLW  F8
0210:  MOVWF  F94
0212:  BSF    F8B.0
....................             output_low(LED_M); 
0214:  MOVWF  F94
0216:  BCF    F8B.1
....................             output_low(LED_S); 
0218:  MOVWF  F94
021A:  BCF    F8B.2
....................         } else if (modoOperacion == 'M') { 
021C:  BRA    025E
021E:  MOVF   54,W
0220:  SUBLW  4D
0222:  BNZ   0234
....................             output_high(LED_M); 
0224:  MOVLW  F8
0226:  MOVWF  F94
0228:  BSF    F8B.1
....................             output_low(LED_J); 
022A:  MOVWF  F94
022C:  BCF    F8B.0
....................             output_low(LED_S); 
022E:  MOVWF  F94
0230:  BCF    F8B.2
....................         } else if (modoOperacion == 'C') { 
0232:  BRA    025E
0234:  MOVF   54,W
0236:  SUBLW  43
0238:  BNZ   024A
....................             output_low(LED_M); 
023A:  MOVLW  F8
023C:  MOVWF  F94
023E:  BCF    F8B.1
....................             output_high(LED_J); 
0240:  MOVWF  F94
0242:  BSF    F8B.0
....................             output_high(LED_S); 
0244:  MOVWF  F94
0246:  BSF    F8B.2
....................         } else if (modoOperacion == 'R') { 
0248:  BRA    025E
024A:  MOVF   54,W
024C:  SUBLW  52
024E:  BNZ   025E
....................             output_low(LED_M); 
0250:  MOVLW  F8
0252:  MOVWF  F94
0254:  BCF    F8B.1
....................             output_high(LED_J); 
0256:  MOVWF  F94
0258:  BSF    F8B.0
....................             output_high(LED_S); 
025A:  MOVWF  F94
025C:  BSF    F8B.2
....................         } 
....................  
....................         flagNumeral = 0; 
025E:  CLRF   57
....................         flagEstirar = 1; 
0260:  MOVLW  01
0262:  MOVWF  59
....................         return; 
0264:  BRA    0296
....................  
....................     } else if (rcvchar == '*' && flagAsterisco == 1) { 
0266:  BRA    0296
0268:  MOVF   51,W
026A:  SUBLW  2A
026C:  BNZ   028A
026E:  DECFSZ 56,W
0270:  BRA    028A
....................         flagAsterisco = 0; 
0272:  CLRF   56
....................         flagComando = 1; 
0274:  MOVLW  01
0276:  MOVWF  55
....................         cantPaquetes = cantCaracteres / 8; 
0278:  RRCF   52,W
027A:  MOVWF  53
027C:  RRCF   53,F
027E:  RRCF   53,F
0280:  MOVLW  1F
0282:  ANDWF  53,F
....................         disable_interrupts(INT_RDA); 
0284:  BCF    F9D.5
....................         return; 
0286:  BRA    0296
....................  
....................     } else if (rcvchar == '$' && flagDollar == 1) { 
0288:  BRA    0296
028A:  MOVF   51,W
028C:  SUBLW  24
028E:  BNZ   0296
0290:  DECFSZ 58,W
0292:  BRA    0296
....................         flagDollar = 0; 
0294:  CLRF   58
....................         return; 
....................     } 
....................  
.................... } 
....................  
....................  
0296:  BCF    F9E.5
0298:  GOTO   0060
.................... #int_TIMER0 
....................  
.................... void TIMER0_isr(void) { 
....................  
....................     mover_motor(0); 
*
0CD8:  MOVLB  1
0CDA:  CLRF   xE2
0CDC:  MOVLB  0
0CDE:  CALL   0316
....................     mover_motor(1); 
0CE2:  MOVLW  01
0CE4:  MOVLB  1
0CE6:  MOVWF  xE2
0CE8:  MOVLB  0
0CEA:  CALL   0316
....................     mover_motor(2); 
0CEE:  MOVLW  02
0CF0:  MOVLB  1
0CF2:  MOVWF  xE2
0CF4:  MOVLB  0
0CF6:  CALL   0316
....................     mover_motor(3); 
0CFA:  MOVLW  03
0CFC:  MOVLB  1
0CFE:  MOVWF  xE2
0D00:  MOVLB  0
0D02:  CALL   0316
....................     mover_motor(4); 
0D06:  MOVLW  04
0D08:  MOVLB  1
0D0A:  MOVWF  xE2
0D0C:  MOVLB  0
0D0E:  CALL   0316
....................     mover_motor(5); 
0D12:  MOVLW  05
0D14:  MOVLB  1
0D16:  MOVWF  xE2
0D18:  MOVLB  0
0D1A:  CALL   0316
....................  
....................     if (pasos[0] == 0 && pasos[1] == 0 && pasos[2] == 0 && pasos[3] == 0 && pasos[4] == 0 && pasos[5] == 0) { 
0D1E:  MOVF   x95,F
0D20:  BTFSS  FD8.2
0D22:  BRA    0E74
0D24:  MOVF   x96,F
0D26:  BTFSS  FD8.2
0D28:  BRA    0E74
0D2A:  MOVF   x97,F
0D2C:  BTFSS  FD8.2
0D2E:  BRA    0E74
0D30:  MOVF   x98,F
0D32:  BTFSS  FD8.2
0D34:  BRA    0E74
0D36:  MOVF   x99,F
0D38:  BTFSS  FD8.2
0D3A:  BRA    0E74
0D3C:  MOVF   x9A,F
0D3E:  BTFSS  FD8.2
0D40:  BRA    0E74
0D42:  MOVF   x9B,F
0D44:  BTFSS  FD8.2
0D46:  BRA    0E74
0D48:  MOVF   x9C,F
0D4A:  BTFSS  FD8.2
0D4C:  BRA    0E74
0D4E:  MOVF   x9D,F
0D50:  BTFSS  FD8.2
0D52:  BRA    0E74
0D54:  MOVF   x9E,F
0D56:  BTFSS  FD8.2
0D58:  BRA    0E74
0D5A:  MOVF   x9F,F
0D5C:  BTFSS  FD8.2
0D5E:  BRA    0E74
0D60:  MOVF   xA0,F
0D62:  BTFSS  FD8.2
0D64:  BRA    0E74
0D66:  MOVF   xA1,F
0D68:  BTFSS  FD8.2
0D6A:  BRA    0E74
0D6C:  MOVF   xA2,F
0D6E:  BTFSS  FD8.2
0D70:  BRA    0E74
0D72:  MOVF   xA3,F
0D74:  BTFSS  FD8.2
0D76:  BRA    0E74
0D78:  MOVF   xA4,F
0D7A:  BTFSS  FD8.2
0D7C:  BRA    0E74
0D7E:  MOVF   xA5,F
0D80:  BTFSS  FD8.2
0D82:  BRA    0E74
0D84:  MOVF   xA6,F
0D86:  BTFSS  FD8.2
0D88:  BRA    0E74
0D8A:  MOVF   xA7,F
0D8C:  BTFSS  FD8.2
0D8E:  BRA    0E74
0D90:  MOVF   xA8,F
0D92:  BTFSS  FD8.2
0D94:  BRA    0E74
0D96:  MOVF   xA9,F
0D98:  BTFSS  FD8.2
0D9A:  BRA    0E74
0D9C:  MOVF   xAA,F
0D9E:  BNZ   0E74
0DA0:  MOVF   xAB,F
0DA2:  BNZ   0E74
0DA4:  MOVF   xAC,F
0DA6:  BNZ   0E74
....................  
....................         if (flagEstirar2 == 1) { 
0DA8:  DECFSZ 5A,W
0DAA:  BRA    0E20
....................              
....................             if (flagS == 1) { 
0DAC:  DECFSZ x63,W
0DAE:  BRA    0DC4
....................                 printf("$S$"); 
0DB0:  MOVLW  82
0DB2:  MOVWF  FF6
0DB4:  MOVLW  0E
0DB6:  MOVWF  FF7
0DB8:  CALL   00DA
....................                 flagS = 0; 
0DBC:  CLRF   x63
....................                 flagCrearSecuenciaInit = 1; 
0DBE:  MOVLW  01
0DC0:  MOVWF  x67
....................             } else if (flagF == 1) { 
0DC2:  BRA    0DE8
0DC4:  DECFSZ x64,W
0DC6:  BRA    0DDC
....................                 printf("$F$"); 
0DC8:  MOVLW  86
0DCA:  MOVWF  FF6
0DCC:  MOVLW  0E
0DCE:  MOVWF  FF7
0DD0:  CALL   00DA
....................                 flagCrearSecuenciaInit = 1; 
0DD4:  MOVLW  01
0DD6:  MOVWF  x67
....................                 flagF = 0; 
0DD8:  CLRF   x64
....................             } else{  
0DDA:  BRA    0DE8
....................                 printf("$OK$"); 
0DDC:  MOVLW  8A
0DDE:  MOVWF  FF6
0DE0:  MOVLW  0E
0DE2:  MOVWF  FF7
0DE4:  CALL   00DA
....................             } 
....................              
....................             pasosmax[1] = 4300; 
0DE8:  MOVLB  1
0DEA:  CLRF   x42
0DEC:  CLRF   x41
0DEE:  MOVLW  10
0DF0:  MOVWF  x40
0DF2:  MOVLW  CC
0DF4:  MOVWF  x3F
....................             pasosmax[2] = 35000; 
0DF6:  CLRF   x46
0DF8:  CLRF   x45
0DFA:  MOVLW  88
0DFC:  MOVWF  x44
0DFE:  MOVLW  B8
0E00:  MOVWF  x43
....................             pasosmin[1] = 1000; 
0E02:  CLRF   x5A
0E04:  CLRF   x59
0E06:  MOVLW  03
0E08:  MOVWF  x58
0E0A:  MOVLW  E8
0E0C:  MOVWF  x57
....................             pasosmin[2] = 5700;  
0E0E:  CLRF   x5E
0E10:  CLRF   x5D
0E12:  MOVLW  16
0E14:  MOVWF  x5C
0E16:  MOVLW  44
0E18:  MOVWF  x5B
....................              
....................             flagEstirar2 = 0; 
0E1A:  CLRF   5A
....................              
....................         } else flagArmarPaquete = 1; 
0E1C:  BRA    0E26
0E1E:  MOVLB  0
0E20:  MOVLW  01
0E22:  MOVWF  x65
0E24:  MOVLB  1
....................  
....................         disable_interrupts(INT_TIMER0); 
0E26:  BCF    FF2.5
....................         flagTimer = 0; 
0E28:  MOVLB  0
0E2A:  CLRF   x61
....................         inicbuff(); 
0E2C:  RCALL  0CB4
....................         j = 0; 
0E2E:  CLRF   x94
....................  
....................         for (j = 0; j < 6; j++) { 
0E30:  CLRF   x94
0E32:  MOVF   x94,W
0E34:  SUBLW  05
0E36:  BNC   0E74
....................             for (i = 0; i < 6; i++) { 
0E38:  CLRF   x93
0E3A:  MOVF   x93,W
0E3C:  SUBLW  05
0E3E:  BNC   0E70
....................                 motor[i][j] = 0; 
0E40:  MOVF   x93,W
0E42:  MULLW  07
0E44:  MOVF   FF3,W
0E46:  MOVLB  1
0E48:  CLRF   xE3
0E4A:  MOVWF  xE2
0E4C:  CLRF   03
0E4E:  MOVLB  0
0E50:  MOVF   x94,W
0E52:  MOVLB  1
0E54:  ADDWF  xE2,W
0E56:  MOVWF  01
0E58:  MOVF   xE3,W
0E5A:  ADDWFC 03,F
0E5C:  MOVF   01,W
0E5E:  ADDLW  69
0E60:  MOVWF  FE9
0E62:  MOVLW  00
0E64:  ADDWFC 03,W
0E66:  MOVWF  FEA
0E68:  CLRF   FEF
0E6A:  MOVLB  0
0E6C:  INCF   x93,F
0E6E:  BRA    0E3A
....................             } 
0E70:  INCF   x94,F
0E72:  BRA    0E32
....................         } 
....................  
....................     } 
....................  
....................     set_timer0(interrupVel); 
0E74:  CLRF   FD7
0E76:  MOVFF  138,FD6
....................     flagTimer = 0; 
0E7A:  CLRF   x61
....................  
0E7C:  BCF    FF2.2
0E7E:  GOTO   0060
.................... } 
....................  
.................... // main ///////////////////////////////////////////////////// 
....................  
.................... void main() { 
*
2CD8:  CLRF   FF8
2CDA:  BCF    FD0.7
2CDC:  BSF    07.7
2CDE:  CLRF   1D
2CE0:  BSF    FB8.3
2CE2:  MOVLW  E1
2CE4:  MOVWF  FAF
2CE6:  MOVLW  04
2CE8:  MOVWF  FB0
2CEA:  MOVLW  A6
2CEC:  MOVWF  FAC
2CEE:  MOVLW  90
2CF0:  MOVWF  FAB
2CF2:  CLRF   1E
2CF4:  CLRF   51
2CF6:  CLRF   52
2CF8:  CLRF   53
2CFA:  CLRF   54
2CFC:  CLRF   55
2CFE:  CLRF   56
2D00:  CLRF   57
2D02:  CLRF   58
2D04:  CLRF   59
2D06:  CLRF   5A
2D08:  CLRF   x61
2D0A:  CLRF   x62
2D0C:  CLRF   x63
2D0E:  CLRF   x64
2D10:  CLRF   x65
2D12:  CLRF   x66
2D14:  CLRF   x67
2D16:  CLRF   x68
2D18:  CLRF   x93
2D1A:  CLRF   x94
2D1C:  MOVLB  1
2D1E:  CLRF   x37
2D20:  MOVLW  96
2D22:  MOVWF  x38
2D24:  MOVLW  03
2D26:  MOVWF  x3A
2D28:  MOVLW  E8
2D2A:  MOVWF  x39
2D2C:  MOVF   FC1,W
2D2E:  ANDLW  C0
2D30:  IORLW  0F
2D32:  MOVWF  FC1
2D34:  MOVLW  07
2D36:  MOVWF  FB4
2D38:  BRA    2D90
2D3A:  DATA 02,00
2D3C:  DATA 17,00
2D3E:  DATA 00,06
2D40:  DATA 40,5B
2D42:  DATA 00,2A
2D44:  DATA 40,69
2D46:  DATA 00,3C
2D48:  DATA 40,95
2D4A:  DATA 00,0A
2D4C:  DATA 80,46
2D4E:  DATA 14,00
2D50:  DATA 00,C4
2D52:  DATA 09,00
2D54:  DATA 00,EA
2D56:  DATA 56,06
2D58:  DATA C0,00
2D5A:  DATA 02,80
2D5C:  DATA 90,1A
2D5E:  DATA 54,C0
2D60:  DATA 00,16
2D62:  DATA 01,3B
2D64:  DATA 8B,28
2D66:  DATA 00,00
2D68:  DATA 63,12
2D6A:  DATA 00,00
2D6C:  DATA D5,AD
2D6E:  DATA 00,00
2D70:  DATA 94,11
2D72:  DATA 00,00
2D74:  DATA 19,35
2D76:  DATA 00,00
2D78:  DATA 00,19
2D7A:  DATA 1A,C0
2D7C:  DATA 00,06
2D7E:  DATA C0,2B
2D80:  DATA 0C,80
2D82:  DATA 46,14
2D84:  DATA C4,09
2D86:  DATA EA,56
2D88:  DATA 00,00
2D8A:  DATA 90,1A
2D8C:  DATA 00,00
2D8E:  DATA 00,00
2D90:  MOVLW  00
2D92:  MOVWF  FF8
2D94:  MOVLW  2D
2D96:  MOVWF  FF7
2D98:  MOVLW  3A
2D9A:  MOVWF  FF6
2D9C:  TBLRD*+
2D9E:  MOVF   FF5,W
2DA0:  MOVWF  00
2DA2:  XORLW  00
2DA4:  BZ    2DCC
2DA6:  TBLRD*+
2DA8:  MOVF   FF5,W
2DAA:  MOVWF  01
2DAC:  BTFSC  FE8.7
2DAE:  BRA    2DBA
2DB0:  ANDLW  0F
2DB2:  MOVWF  FEA
2DB4:  TBLRD*+
2DB6:  MOVFF  FF5,FE9
2DBA:  BTFSC  01.6
2DBC:  TBLRD*+
2DBE:  BTFSS  01.6
2DC0:  TBLRD*+
2DC2:  MOVFF  FF5,FEE
2DC6:  DCFSNZ 00,F
2DC8:  BRA    2D9C
2DCA:  BRA    2DBE
2DCC:  CLRF   FF8
2DCE:  CLRF   16
2DD0:  BTFSC  FF2.7
2DD2:  BSF    16.7
2DD4:  BCF    FF2.7
....................  
....................     inicbuff(); // Borra buffer al inicio 
2DD6:  MOVLB  0
2DD8:  CALL   0CB4
2DDC:  BTFSC  16.7
2DDE:  BSF    FF2.7
....................  
....................     output_high(LED_M); 
2DE0:  MOVLW  F8
2DE2:  MOVWF  F94
2DE4:  BSF    F8B.1
....................     output_high(LED_J); 
2DE6:  MOVWF  F94
2DE8:  BSF    F8B.0
....................     output_high(LED_S); 
2DEA:  MOVWF  F94
2DEC:  BSF    F8B.2
....................  
....................     delay_ms(3000); 
2DEE:  MOVLW  0C
2DF0:  MOVLB  1
2DF2:  MOVWF  x7D
2DF4:  MOVLW  FA
2DF6:  MOVWF  x91
2DF8:  MOVLB  0
2DFA:  CALL   0E90
2DFE:  MOVLB  1
2E00:  DECFSZ x7D,F
2E02:  BRA    2DF4
....................  
....................     home(PRIMERO); 
2E04:  MOVLW  01
2E06:  MOVWF  x7D
2E08:  MOVLB  0
2E0A:  CALL   0FA4
....................      
....................     setup_timer_0(RTCC_INTERNAL | RTCC_8_BIT | RTCC_DIV_1); //Configuración timer0 
2E0E:  MOVLW  C8
2E10:  MOVWF  FD5
....................     enable_interrupts(GLOBAL); //Habilita interrupción general 
2E12:  MOVLW  C0
2E14:  IORWF  FF2,F
....................     enable_interrupts(INT_RDA); // Habilita Interrupción RDA 
2E16:  BSF    F9D.5
....................  
....................     while (1) { 
....................  
....................         if (flagArmarPaquete == 1) { 
2E18:  DECFSZ x65,W
2E1A:  BRA    2E22
....................             flagArmarPaquete = 0; 
2E1C:  CLRF   x65
....................             armarPaquete(); 
2E1E:  GOTO   16DA
....................         } 
....................  
....................         if (flagHome == 1) { 
2E22:  DECFSZ x62,W
2E24:  BRA    2E32
....................             home(OTRO); 
2E26:  MOVLB  1
2E28:  CLRF   x7D
2E2A:  MOVLB  0
2E2C:  CALL   0FA4
....................             flagHome = 0; 
2E30:  CLRF   x62
....................         } 
....................  
....................         if (flagEstirar == 1) { 
2E32:  DECFSZ 59,W
2E34:  BRA    2E3C
....................             estirar(); 
2E36:  GOTO   1E48
....................             flagEstirar = 0; 
2E3A:  CLRF   59
....................         } 
....................  
....................         if (flagComando == 1) { // Si hay comando pendiente 
2E3C:  DECFSZ 55,W
2E3E:  BRA    2E42
....................             procesa_comando(); // de procesar ... lo procesa. 
2E40:  BRA    2728
....................         } 
....................  
....................         if (flagTimer == 1) { 
2E42:  DECFSZ x61,W
2E44:  BRA    2E48
....................             enable_interrupts(INT_TIMER0); //Habilita interrupción timer0 
2E46:  BSF    FF2.5
....................         } 
....................  
....................         if (flagCrearSecuenciaInit == 1) { 
2E48:  DECFSZ x67,W
2E4A:  BRA    2E50
....................             flagCrearSecuenciaInit = 0; 
2E4C:  CLRF   x67
....................             crearSecInit(); 
2E4E:  BRA    29AC
....................         } 
....................  
....................         if (flagPasosDados == 1) { 
2E50:  DECFSZ x66,W
2E52:  BRA    2E58
....................             flagPasosDados = 0; 
2E54:  CLRF   x66
....................             calcularPasosDados(); 
2E56:  BRA    2A72
....................         } 
2E58:  BRA    2E18
....................  
....................     } 
....................  
.................... } 
2E5A:  SLEEP 

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
